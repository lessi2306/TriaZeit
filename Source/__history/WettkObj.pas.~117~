unit WettkObj;

interface

uses
  Windows,Classes,SysUtils,Dialogs,Controls,Math,
  AllgConst,Allgfunc,AllgObj,AkObj,OrtObj;

type
  TCupWrtgPktRec = record
    RngVon,RngBis,PktVon,PktIncr : Integer;
  end;
  PCupWrtgPktRec = ^TCupWrtgPktRec;
  
  TCupWrtgPktColl = class(TTriaColl)
  protected
    function  GetBPObjType: Word; override;
    function  GetPItem(Indx:Integer): PCupWrtgPktRec;
    procedure SetPItem(Indx:Integer; Item:PCupWrtgPktRec);
    procedure FreeItem(Item: Pointer); override;
    function  LoadItem(Indx:Integer): Boolean; override;
    function  StoreItem(Indx:Integer): Boolean; override;
  public
    constructor Create(Veranst:Pointer);
    function  Add(Rec:TCupWrtgPktRec): Integer;
    function  GetCupPkt(Rng:integer): Integer;
    function  CupPktIncr: Boolean;
    property Items[Indx: Integer]: PCupWrtgPktRec read GetPItem write SetPItem; default;
  end;

  TRngMaxAkColl = class(TTriaColl)
  protected
    function  GetPItem(Indx:Integer): TWordCollection;
    procedure SetPItem(Indx:Integer; Coll:TWordCollection);
    procedure FreeItem(Item: Pointer); override;
    function  LoadItem(Indx:Integer): Boolean; override;
    function  StoreItem(Indx:Integer): Boolean; override;
  public
    AkRngColl : TAkColl; // AkColl gilt für alle Orte
    constructor Create(Veranst:Pointer;AkCollNeu:TAkColl);
    //procedure RngCollAdd(AkColl:TAkColl);
    function Add(Rng: Integer): Integer;
    property Items[Indx: Integer]: TWordCollection read GetPItem write SetPItem; default;
  end;


  TWettkObj = Class(TTriaObj)
  protected
    // allgemeine Daten
    // bei WettkAlleDummy: FVPtr=Veranstaltung=nil möglich
    FName                  : String;
    FStreichErg,
    FStreichOrt            : array[tmTln..tmMsch] of Integer;
    FPflichtWkMode         : array[tmTln..tmMsch] of TPflichtWkMode;
    FSerWrtgJahr           : Integer; // nur bei Serienwertung benutzt
    FPflichtWkOrt1,
    FPflichtWkOrt2,
    FPunktGleichOrt        : array[tmTln..tmMsch] of TOrtObj; // Favorite Ort bei Punktgleichheit
    FMschWertg             : TMschWertung;
    FMannschModified       : Boolean;
    FKlassenModified       : Boolean;
    FTlnMKlasse            : TAkObj; // 2005, nur Name wird gespeichert
    FTlnWKlasse            : TAkObj;
    FMschMKlasse           : TAkObj;
    FMschWKlasse           : TAkObj;
    FTlnSerPktMode         : TSerPktMode;
    FMschSerPktMode        : TSerPktMode;
    FTlnCupWrtgPktColl     : TCupWrtgPktColl;
    FMschCupWrtgPktColl    : TCupWrtgPktColl;

    // Ortsbezogene Daten
    FStandTitelColl        : TTextCollection;
    FSondTitelColl         : TTextCollection; // 2005: Sonderwertung pro wettk
    FDatumColl             : TTextCollection;
    FWettkArtColl          : TWordCollection;
    FMschWrtgModeColl      : TWordCollection;
    FMannschGrAnmColl      : TWordCollection;
    FMannschGrStrtColl     : TWordCollection;
    //FMannschGrWrtgColl     : TWordCollection;
    FMschGrAlleColl        : TWordCollection;
    FMschGrMaennerColl     : TWordCollection; // 2011-2.4, nicht für Liga
    FMschGrFrauenColl      : TWordCollection; // 2011-2.4, nicht für Liga
    FMschGrMixedColl       : TWordCollection; // 2011-2.4, nicht für Liga
    FSchwimmDistanzColl    : TWordCollection;
    FStartBahnenColl       : TWordCollection;
    FErgModifiedColl       : TBoolCollection;
    FAbschnZahlColl        : TWordCollection;
    FAbschnNameCollArr     : array [wkAbs1..wkAbs8] of TTextCollection;
    FTlnTxtColl            : TTextCollection;
    FAbschnRundCollArr     : array [wkAbs1..wkAbs8] of TWordCollection;

    FRngMaxTlnAlleColl,                // für Serien-Punktwertung mit spRngDownPkt
    FRngMaxTlnMaennerColl,             // RngMax für jede Klasse nach Berechnung festhalten
    FRngMaxTlnFrauenColl,
    FRngMaxMschAlleColl,
    FRngMaxMschMaennerColl,
    FRngMaxMschFrauenColl,
    FRngMaxMschMixedColl   : TWordCollection; // Wert pro Ort
    FRngMaxTlnAkMColl,
    FRngMaxTlnSkMColl,
    FRngMaxMschAkMColl,
    FRngMaxTlnAkWColl,
    FRngMaxTlnSkWColl,
    FRngMaxMschAkWColl     : TRngMaxAkColl; // Wert pro Ort,Klasse

    function    GetBPObjType: Word; override;
    procedure   SetName(NameNeu:String);
    function    GetStreichErg(TlnMsch:TTlnMsch): Integer;
    procedure   SetStreichErg(TlnMsch:TTlnMsch; const StreichErgNeu:integer);
    function    GetStreichOrt(TlnMsch:TTlnMsch): Integer;
    procedure   SetStreichOrt(TlnMsch:TTlnMsch; const StreichOrtNeu:integer);
    procedure   SetSerWrtgJahr(const JahrNeu: Integer);
    function    GetPflichtWkMode(TlnMsch:TTlnMsch): TPflichtWkMode;
    procedure   SetPflichtWkMode(TlnMsch:TTlnMsch; PflichtWkModeNeu:TPflichtWkMode);
    function    GetPflichtWkOrt1(TlnMsch:TTlnMsch): TOrtObj;
    procedure   SetPflichtWkOrt1(TlnMsch:TTlnMsch; OrtNeu:TOrtObj);
    function    GetPflichtWkOrt1Indx(TlnMsch:TTlnMsch): Integer;
    procedure   SetPflichtWkOrt1Indx(TlnMsch:TTlnMsch; IndxNeu:Integer);
    function    GetPflichtWkOrt2(TlnMsch:TTlnMsch): TOrtObj;
    procedure   SetPflichtWkOrt2(TlnMsch:TTlnMsch; OrtNeu:TOrtObj);
    function    GetPflichtWkOrt2Indx(TlnMsch:TTlnMsch): Integer;
    procedure   SetPflichtWkOrt2Indx(TlnMsch:TTlnMsch; IndxNeu:Integer);
    function    GetPunktGleichOrt(TlnMsch:TTlnMsch): TOrtObj;
    procedure   SetPunktGleichOrt(TlnMsch:TTlnMsch; OrtNeu:TOrtObj);
    function    GetPunktGleichOrtIndx(TlnMsch:TTlnMsch): Integer;
    procedure   SetPunktGleichOrtIndx(TlnMsch:TTlnMsch; IndxNeu:Integer);
    function    GetMschWertg: TMschWertung;
    procedure   SetMschWertg(WertgNeu:TMschWertung);
    function    GetTlnSerPktMode: TSerPktMode;
    procedure   SetTlnSerPktMode(SerPktModeNeu:TSerPktMode);
    function    GetMschSerPktMode: TSerPktMode;
    procedure   SetMschSerPktMode(SerPktModeNeu:TSerPktMode);
    procedure   SetMannschModified(ModifiedNeu:Boolean);
    procedure   SetKlassenModified(ModifiedNeu:Boolean);
    function    GetErgModified: Boolean;
    function    GetOrtErgModified(Indx:Integer): Boolean;
    procedure   SetErgModified(ModifiedNeu:Boolean);
    procedure   SetOrtErgModified(Indx:Integer; ModifiedNeu:Boolean);
    function    GetOrtStandTitel(Indx:Integer): String;
    function    GetStandTitel: String;
    procedure   SetOrtStandTitel(Indx:Integer; StandTitelNeu:String);
    procedure   SetStandTitel(StandTitelNeu:String);
    function    GetSondWrtg: Boolean;
    function    GetSondTitel: String;
    function    GetOrtSondTitel(Indx:Integer): String;
    procedure   SetSondTitel(SondTitelNeu:String);
    procedure   SetOrtSondTitel(Indx:Integer; SondTitelNeu:String);
    function    GetDatum: String;
    procedure   SetDatum(const DatumNeu: String);
    function    GetOrtDatum(Indx:Integer): String;
    procedure   SetOrtDatum(Indx:Integer; const DatumNeu: String);
    function    GetOrtJahr(Indx:Integer): Integer;
    function    GetJahr: Integer;
    //function    GetTlnMKlasse: TAkObj;
    procedure   SetTlnMKlasse(AkNeu:TAkObj);
    //function    GetTlnWKlasse: TAkObj;
    procedure   SetTlnWKlasse(AkNeu:TAkObj);
    procedure   SetMschMKlasse(AkNeu:TAkObj);
    procedure   SetMschWKlasse(AkNeu:TAkObj);
    //function    GetTlnAltMKlasseColl: TAkColl;
    //function    GetTlnAltWKlasseColl: TAkColl;
    //function    GetTlnSondMKlasseColl: TAkColl;
    //function    GetTlnSondWKlasseColl: TAkColl;
    function    GetWettkArt: TWettkArt;
    procedure   SetWettkArt(WkArtNeu:TWettkArt);
    function    GetOrtWettkArt(Indx:Integer): TWettkArt;
    procedure   SetOrtWettkArt(Indx:Integer; WkArtNeu:TWettkArt);
    function    GetMschWrtgMode: TMschWrtgMode;
    procedure   SetMschWrtgMode(MschWrtgModeNeu:TMschWrtgMode);
    function    GetOrtMschWrtgMode(Indx:Integer): TMschWrtgMode;
    procedure   SetOrtMschWrtgMode(Indx:Integer; MschWrtgModeNeu:TMschWrtgMode);
    function    GetMannschGrAnm: Integer;
    procedure   SetMannschGrAnm(Groesse:Integer);
    function    GetOrtMannschGrAnm(Indx:Integer): Integer;
    procedure   SetOrtMannschGrAnm(Indx:Integer; Groesse:Integer);
    function    GetMannschGrStrt: Integer;
    procedure   SetMannschGrStrt(Groesse:Integer);
    function    GetOrtMannschGrStrt(Indx:Integer): Integer;
    procedure   SetOrtMannschGrStrt(Indx:Integer; Groesse:Integer);
    //function    GetMannschGrWrtg: Integer;
    //procedure   SetMannschGrWrtg(Groesse:Integer);
    //function    GetOrtMannschGrWrtg(Indx:Integer): Integer;
    //procedure   SetOrtMannschGrWrtg(Indx:Integer; Groesse:Integer);
    function    GetMschGroesse(Sx:TSex): Integer;
    procedure   SetMschGroesse(Sx:TSex; Groesse:Integer);
    function    GetOrtMschGroesse(Sx:TSex;Indx:Integer): Integer;
    procedure   SetOrtMschGroesse(Sx:TSex;Indx:Integer; Groesse:Integer);
    function    GetSchwimmDistanz: Integer;
    function    GetOrtSchwimmDistanz(Indx:Integer): Integer;
    procedure   SetSchwimmDistanz(SchwimmDistanz:Integer);
    procedure   SetOrtSchwimmDistanz(Indx:Integer; SchwimmDistanz:Integer);
    function    GetStartBahnen: Integer;
    function    GetOrtStartBahnen(Indx:Integer): Integer;
    procedure   SetStartBahnen(StartBahnen:Integer);
    procedure   SetOrtStartBahnen(Indx:Integer; StartBahnen:Integer);
    function    GetAbschnZahl: Integer;
    procedure   SetAbschnZahl(ZahlNeu:Integer);
    function    GetOrtAbschnZahl(Indx:Integer): Integer;
    procedure   SetOrtAbschnZahl(Indx,ZahlNeu:Integer);
    function    GetAbschnNameColl(Abschnitt:TWkAbschnitt): TTextCollection;
    function    GetAbschnName(Abschnitt:TWkAbschnitt): String;
    procedure   SetAbschnName(Abschnitt:TWkAbschnitt;NameNeu:String);
    function    GetOrtAbschnName(Indx:Integer;Abschnitt:TWkAbschnitt): String;
    procedure   SetOrtAbschnName(Indx:Integer;Abschnitt:TWkAbschnitt;NameNeu:String);
    function    GetTlnTxt: String;
    function    GetAbschnRunden(Abschnitt:TWkAbschnitt): Integer;
    procedure   SetAbschnRunden(Abschnitt:TWkAbschnitt;RundenNeu:Integer);
    function    GetOrtAbschnRunden(Indx:Integer;Abschnitt:TWkAbschnitt): Integer;
    procedure   SetTlnTxt(TxtNeu:String);
    function    GetOrtTlnTxt(Indx:Integer): String;
    procedure   SetOrtTlnTxt(Indx:Integer;TxtNeu:String);

  public
    TlnAkZahlMax,
    MschAkZahlMax      : Integer;            // für Ergebnisse Berechnen
    TlnImZielColl      : TBoolCollection;    // nur bei Serienwertung benutzt
    OrtZahlGestartet   : Integer;            // nur bei Serienwertung benutzt
    RngBuffColl        : TIntSortCollection; // nur bei Serienwertung benutzt
    TlnAltMKlasseColl  : TAkColl; // alle AltKlassen für Tln-Wertung-M
    TlnSondMKlasseColl : TAkColl; // alle SondKlassen für Tln-Wertung-M
    MschAltMKlasseColl : TAkColl; // alle AltKlassen für Msch-Wertung-M
    TlnAltWKlasseColl  : TAkColl; // alle AltKlassen für Tln-Wertung-W
    TlnSondWKlasseColl : TAkColl; // alle SondKlassen für Tln-Wertung-W
    MschAltWKlasseColl : TAkColl; // alle AltKlassen für Msch-Wertung-W

    constructor Create(Veranst:Pointer;Coll:TTriaObjColl;Add:TOrtAdd); override;
    destructor  Destroy; override;
    function    Load: Boolean; override;
    function    Store: Boolean; override;
    procedure   OrtCollAdd; override;
    procedure   OrtCollClear(Indx:Integer); override;
    procedure   OrtCollExch(Idx1,Idx2:Integer); override;
    procedure   SetWettkAllgDaten(Name: String;
                                  StreichErgTlnNeu,StreichErgMschNeu:Integer;
                                  StreichOrtTlnNeu,StreichOrtMschNeu: Integer;
                                  PflichtWkModeTlnNeu,PflichtWkModeMschNeu: TPflichtWkMode;
                                  PflichtWkOrt1TlnNeu,PflichtWkOrt1MschNeu,
                                  PflichtWkOrt2TlnNeu,PflichtWkOrt2MschNeu: TOrtObj;
                                  PunktGleichOrtTlnNeu,PunktGleichOrtMschNeu:TOrtObj;
                                  MschWertgNeu:TMschWertung;
                                  SerWrtgJahrNeu:Integer;
                                  TlnSerPktModeNeu,MschSerPktModeNeu:TSerPktMode);
    procedure   SetWettkOrtDaten(StandTitelNeu,SondTitelNeu,DatumNeu:String;
                                 WettkArtNeu:TWettkArt;AbschnZahlNeu,
                                 Abs1RndNeu,Abs2RndNeu,Abs3RndNeu,Abs4RndNeu,
                                 Abs5RndNeu,Abs6RndNeu,Abs7RndNeu,Abs8RndNeu:Integer;
                                 Abs1NameNeu,Abs2NameNeu,Abs3NameNeu,Abs4NameNeu,
                                 Abs5NameNeu,Abs6NameNeu,Abs7NameNeu,Abs8NameNeu,
                                 TlnTxtNeu:String; MschWrtgModeNeu:TMschWrtgMode;
                                 MannschGrAnmNeu,MannschGrStrtNeu,MschGrAlleNeu,
                                 MschGrMaennerNeu,MschGrFrauenNeu,MschGrMixedNeu,
                                 SchwimmDistanzNeu,StartBahnenNeu:Integer);
    function    GetTlnAlter(Jg:Integer): Integer;
    function    GetTlnKlasse(AkWrtg:TKlassenWertung;Sx:TSex;Jg:Integer):TAkObj;
    function    GetMschKlasse(AkWrtg:TKlassenWertung;Sx:TSex; Jg:Integer):TAkObj;
    function    MschGroesseMin: Integer;
    function    MschGroesseMax: Integer;
    procedure   KlasseCollKopieren(ZielColl,QuelColl:TAkColl);
    procedure   KlassenKopieren(Wk:TWettkObj);
    //procedure   CupWrtgCollKopieren(ZielColl,QuelColl:TCupWrtgPktColl);
    function    TlnOrtSerPkt(Indx:Integer;Klasse:TAkObj;Rng:Integer): Integer;
    function    MschOrtSerPkt(Indx:Integer;Klasse:TAkObj;Rng:integer): Integer;
    function    TlnCupPktIncr: Boolean;
    function    MschCupPktIncr: Boolean;
    function    EinzelWettk: Boolean;
    function    EinzelStart: Boolean;
    function    MschWettk: Boolean;
    function    TlnOrtSerWertung(Indx:Integer): Boolean;
    function    SexSortMode: TSortMode;
    function    JgLang(J:String): Integer;
    function    LangeAkKuerzel: Boolean;
    //function    AbsStartMode(Abs:TWkAbschnitt): TStartMode;
    function    GetSerAkRngMaxColl(TlnMsch:TTlnMsch;AkWrtg:TKlassenWertung;Sx:TSex): TWordCollection;
    procedure   SetSerRngMax(TlnMsch:TTlnMsch;Klasse:TAkObj;Rng:Integer);
    function    ObjSize: Integer; override;

    property Name            : String read FName write SetName;
    property MschWertg       : TMschWertung read GetMschWertg write SetMschWertg;
    property TlnSerPktMode   : TSerPktMode read GetTlnSerPktMode write SetTlnSerPktMode;
    property MschSerPktMode  : TSerPktMode read GetMschSerPktMode write SetMschSerPktMode;
    property MschModified    : Boolean read FMannschModified write SetMannschModified;
    property KlassenModified : Boolean read FKlassenModified write SetKlassenModified;
    property ErgModified     : Boolean read GetErgModified write SetErgModified;
    property OrtErgModified[Indx: Integer]: Boolean read GetOrtErgModified write SetOrtErgModified;
    property OrtStandTitel[Indx: Integer] : String read GetOrtStandTitel ; //write SetOrtStandTitel;
    property StandTitel      : String read GetStandTitel ; //write SetStandTitel;
    property SondWrtg        : Boolean read GetSondWrtg;
    property SondTitel       : String read GetSondTitel write SetSondTitel;
    property OrtSondTitel[Indx: Integer] : String read GetOrtSondTitel write SetOrtSondTitel;
    property Datum           : String read GetDatum write SetDatum;
    property OrtDatum[Indx: Integer]: String read GetOrtDatum write SetOrtDatum;
    property OrtJahr[Indx: Integer]: Integer read GetOrtJahr;
    property TlnMKlasse      : TAkObj read FTlnMKlasse write SetTlnMKlasse;
    property TlnWKlasse      : TAkObj read FTlnWKlasse write SetTlnWKlasse;
    property MschMKlasse     : TAkObj read FMschMKlasse write SetMschMKlasse;
    property MschWKlasse     : TAkObj read FMschWKlasse write SetMschWKlasse;
    property Jahr            : Integer read GetJahr;
    property WettkArt        : TWettkArt read GetWettkArt write SetWettkArt;
    property OrtWettkArt[Indx: Integer]: TWettkArt read GetOrtWettkArt write SetOrtWettkArt;
    property MschWrtgMode    : TMschWrtgMode read GetMschWrtgMode write SetMschWrtgMode;
    property OrtMschWrtgMode[Indx: Integer] : TMschWrtgMode read GetOrtMschWrtgMode write SetOrtMschWrtgMode;
    property MannschGrAnm    : Integer read GetMannschGrAnm write SetMannschGrAnm;
    property OrtMannschGrAnm[Indx: Integer] : Integer
                               read GetOrtMannschGrAnm write SetOrtMannschGrAnm;
    property MannschGrStrt   : Integer read GetMannschGrStrt write SetMannschGrStrt;
    property OrtMannschGrStrt[Indx: Integer] : Integer
                               read GetOrtMannschGrStrt write SetOrtMannschGrStrt;
    //property MannschGrWrtgColl : TWordCollection read FMannschGrWrtgColl write FMannschGrWrtgColl;
    //property MannschGrWrtg   : Integer read GetMannschGrWrtg write SetMannschGrWrtg;
    //property OrtMannschGrWrtg[Indx: Integer] : Integer
    //                           read GetOrtMannschGrWrtg write SetOrtMannschGrWrtg;
    property MschGroesse[Sx:TSex] : Integer read GetMschGroesse write SetMschGroesse;
    property OrtMschGroesse[Sx:TSex;Indx:Integer]: Integer read GetOrtMschGroesse write SetOrtMschGroesse;
    property SchwimmDistanzColl : TWordCollection read FSchwimmDistanzColl write FSchwimmDistanzColl;
    property SchwimmDistanz  : Integer read GetSchwimmDistanz write SetSchwimmDistanz;
    property OrtSchwimmDistanz[Indx: Integer] : Integer read GetOrtSchwimmDistanz write SetOrtSchwimmDistanz;
    property OrtStartBahnen[Indx: Integer] : Integer read GetOrtStartBahnen write SetOrtStartBahnen;
    property StartBahnen     : Integer read GetStartBahnen write SetStartBahnen;
    property AbschnZahl      : Integer read GetAbschnZahl write SetAbschnZahl;
    property OrtAbschnZahl[Indx: Integer]: Integer read GetOrtAbschnZahl write SetOrtAbschnZahl;
    property AbschnName[Abschnitt:TWkAbschnitt] : String
                               read GetAbschnName write SetAbschnName;
    property OrtAbschnName[Indx: Integer;Abschnitt:TWkAbschnitt] : String
                               read GetOrtAbschnName write SetOrtAbschnName;
    property TlnTxt          : String read GetTlnTxt write SetTlnTxt;
    property OrtAbschnRunden[Indx:Integer;Abschnitt:TWkAbschnitt]: Integer read GetOrtAbschnRunden;
    property AbschnRunden[Abschnitt:TWkAbschnitt]: Integer read GetAbschnRunden ;
    property OrtTlnTxt[Indx:Integer]: String read GetOrtTlnTxt write SetOrtTlnTxt;
    //property TlnAltMKlasseColl  : TAkColl read GetTlnAltMKlasseColl;
    //property TlnSondMKlasseColl : TAkColl read GetTlnSondMKlasseColl;
    //property MschAltMKlasseColl : TAkColl read FMschAltMKlasseColl;
    //property TlnAltWKlasseColl  : TAkColl read GetTlnAltWKlasseColl;
    //property TlnSondWKlasseColl : TAkColl read GetTlnSondWKlasseColl;
    //property MschAltWKlasseColl : TAkColl read FMschAltWKlasseColl;
    // Serienwertung
    property StreichErg[TlnMsch:TTlnMsch]         : Integer read GetStreichErg write SetStreichErg;
    property StreichOrt[TlnMsch:TTlnMsch]         : Integer read GetStreichOrt write SetStreichOrt;
    property SerWrtgJahr                          : Integer read FSerWrtgJahr write SetSerWrtgJahr;
    property PflichtWkMode[TlnMsch:TTlnMsch]      : TPflichtWkMode read GetPflichtWkMode write SetPflichtWkMode;
    property PflichtWkOrt1[TlnMsch:TTlnMsch]      : TOrtObj read GetPflichtWkOrt1 write SetPflichtWkOrt1;
    property PflichtWkOrt1Indx[TlnMsch:TTlnMsch]  : Integer read GetPflichtWkOrt1Indx write SetPflichtWkOrt1Indx;
    property PflichtWkOrt2[TlnMsch:TTlnMsch]      : TOrtObj read GetPflichtWkOrt2 write SetPflichtWkOrt2;
    property PflichtWkOrt2Indx[TlnMsch:TTlnMsch]  : Integer read GetPflichtWkOrt2Indx write SetPflichtWkOrt2Indx;
    property PunktGleichOrt[TlnMsch:TTlnMsch]     : TOrtObj read GetPunktGleichOrt write SetPunktGleichOrt;
    property PunktGleichOrtIndx[TlnMsch:TTlnMsch] : Integer read GetPunktGleichOrtIndx write SetPunktGleichOrtIndx;
    property TlnCupWrtgPktColl           : TCupWrtgPktColl read FTlnCupWrtgPktColl write FTlnCupWrtgPktColl;
    property MschCupWrtgPktColl          : TCupWrtgPktColl read FMschCupWrtgPktColl write FMschCupWrtgPktColl;
  end;

  TWettkColl = Class(TTriaObjColl)
  protected
    function    GetBPObjType: Word; override;
    function    GetPItem(Indx:Integer): TWettkObj;
    procedure   SetPItem(Indx:Integer; Item:TWettkObj);
    function    GetSortItem(Indx:Integer): TWettkObj;
  public
    constructor Create(Veranst:Pointer;ItemClass:TTriaObjClass);
    function    SortString(Item: Pointer): String; override;
    function    Compare(Item1, Item2: Pointer): Integer; override;
    function    Load: Boolean; override;
    function    Store: Boolean; override;
    procedure   OrtCollExch(Idx1,Idx2:Integer); override;
    procedure   Sortieren(SortModeNeu: TSortMode);
    function    MannschWettk: Boolean;
    function    AlleAbschnGleich: Boolean;
    function    AlleMitSchwDistanz: Boolean;
    function    KeinOderAlleTlnStaffel: Boolean;
    property Items[Indx: Integer]: TWettkObj read GetPItem write SetPItem; default;
    property SortItems[Indx:Integer]:TWettkObj read GetSortItem;
  end;

  TReportWkObj = class(TObject)
    Wettk : TWettkObj;
    Wrtg  : TWertungMode;
    constructor Create(WkNeu:TWettkObj; WrtgNeu:TWertungMode);
    function Name: String;
  end;

  var WettkAlleDummy : TWettkObj; // für AnsFrame/Sortwettk wenn Veranstaltung=nil
                                  // zum Sortieren und für RaveReports über alle Wettk
implementation

uses TriaMain,VeranObj,DateiDlg, ZtEinlDlg, TlnObj;


(******************************************************************************)
(*  Methoden von TCupWrtgColl                                                 *)
(******************************************************************************)

(*----------------------------------------------------------------------------*)
function TCupWrtgPktColl.GetBPObjType: Word;
(*----------------------------------------------------------------------------*)
(* Object Types aus Version 7.4 Stream Registration Records *)
begin
  Result := rrCupWrtgColl;
end;

(******************************************************************************)
function TCupWrtgPktColl.GetPItem(Indx:Integer): PCupWrtgPktRec;
(******************************************************************************)
begin
  Result := PCupWrtgPktRec(inherited GetPItem(Indx));
end;

(******************************************************************************)
procedure TCupWrtgPktColl.SetPItem(Indx:Integer; Item:PCupWrtgPktRec);
(******************************************************************************)
begin
  inherited SetPItem(Indx,Item);
end;

(******************************************************************************)
procedure TCupWrtgPktColl.FreeItem(Item: Pointer);
(******************************************************************************)
begin
  if Item <> nil then FreeMem(Item,SizeOf(TCupWrtgPktRec));
end;

(******************************************************************************)
function TCupWrtgPktColl.LoadItem(Indx:Integer): Boolean;
(******************************************************************************)
var R : TCupWrtgPktRec;
    P : PCupWrtgPktRec;
begin
  Result := false;
  try
    with TriaStream do
    begin
      ReadBuffer(R.RngVon,cnSizeOfInteger);
      ReadBuffer(R.RngBis,cnSizeOfInteger);
      ReadBuffer(R.PktVon,cnSizeOfInteger);
      ReadBuffer(R.PktIncr,cnSizeOfInteger);
    end;
    New(P); P^ := R;
    if AddItem(P) = Indx then Result := true;
  except
    Exit;
  end;
end;

(******************************************************************************)
function TCupWrtgPktColl.StoreItem(Indx:Integer): Boolean;
(******************************************************************************)
begin
  Result := false;
  try
    if (Indx>=0) and (Indx<Count) and (GetPItem(Indx) <> nil) then
    with TriaStream do with GetPItem(Indx)^ do
    begin
      WriteBuffer(RngVon,cnSizeOfInteger);
      WriteBuffer(RngBis,cnSizeOfInteger);
      WriteBuffer(PktVon,cnSizeOfInteger);
      WriteBuffer(PktIncr,cnSizeOfInteger);
      Result := true;
    end;
  except
    Exit;
  end;
end;

// public Methoden

(******************************************************************************)
constructor TCupWrtgPktColl.Create(Veranst:Pointer);
(******************************************************************************)
begin
  inherited Create(Veranst);
  FItemSize := SizeOf(TCupWrtgPktRec);
end;

(******************************************************************************)
function TCupWrtgPktColl.Add(Rec:TCupWrtgPktRec): Integer;
(******************************************************************************)
var P : PCupWrtgPktRec;
begin
  New(P);
  P^:= Rec;
  Result := AddItem(P);
end;

{//==============================================================================
function TCupWrtgPktColl.GetRng0Pkt: Integer; // 10, 100, 1.000 oder 10.000
//==============================================================================
// Werte: 0, 10, 100, 1.000 oder 10.000
begin
  Result := 0; // bei Decr immer 0 Punkte
  if (Count > 0) and  (GetPItem(0).PktIncr > 0) then // Increment
  begin
    with GetPItem(Count-1)^ do
      Result := PktVon + (RngBis-RngVon)*PktIncr + 1; // 1 mehr als letzter Platz
    if Result < 10 then Result := 10
    else if Result < 100 then Result := 100
    else if Result < 1000 then Result := 1000
    else Result := 10000; // cnTlnMax+1
  end;
end; }

(*============================================================================*)
function TCupWrtgPktColl.GetCupPkt(Rng:integer): Integer;
(*============================================================================*)
// 0 <= Punkte <= cnTlnMax+1 (= 10.000)
var i : Integer;
begin
  if Count > 0 then
  begin
    if GetPItem(0).PktIncr > 0 then // Increment
      with GetPItem(Count-1)^ do
        Result := PktVon + (RngBis-RngVon)*PktIncr + 1 // 1 mehr als letzter Platz
    else Result := 0; // bei Decr immer 0 Punkte

    if (Rng > 0) and (Rng <= GetPItem(Count-1).RngBis) then // gewertet und gepunktet
      for i:=0 to Count-1 do
        with GetPItem(i)^ do
          if Rng <= RngBis then
          begin
            Result := PktVon + (Rng-RngVon)*PktIncr; // immer >0, <=cnTlnMax
            Exit;
          end;
  end
  else Result := 0;
end;

(*============================================================================*)
function TCupWrtgPktColl.CupPktIncr: Boolean;
(*============================================================================*)
begin
  if GetPItem(0).PktIncr > 0 then Result := true
                             else Result := false;
end;

(******************************************************************************)
(*   Methoden von TRngMaxAkColl                                               *)
(******************************************************************************)

//------------------------------------------------------------------------------
function TRngMaxAkColl.GetPItem(Indx:Integer): TWordCollection;
//------------------------------------------------------------------------------
begin
  Result := TWordCollection(inherited GetPItem(Indx));
end;

//------------------------------------------------------------------------------
procedure TRngMaxAkColl.SetPItem(Indx:Integer; Coll:TWordCollection);
//------------------------------------------------------------------------------
begin
  inherited SetPItem(Indx,Coll);
end;

//------------------------------------------------------------------------------
procedure TRngMaxAkColl.FreeItem(Item: Pointer);
//------------------------------------------------------------------------------
begin
  if Item <> nil then FreeAndNil(TWordCollection(Item));
end;

//------------------------------------------------------------------------------
function TRngMaxAkColl.LoadItem(Indx:Integer): Boolean;
//------------------------------------------------------------------------------
begin
  // nicht benutzt, nur um Compiler-Warnung zu vermeiden
  Result := false;
end;

//------------------------------------------------------------------------------
function TRngMaxAkColl.StoreItem(Indx:Integer): Boolean;
//------------------------------------------------------------------------------
begin
  // nicht benutzt, nur um Compiler-Warnung zu vermeiden
  Result := false;
end;

//==============================================================================
constructor TRngMaxAkColl.Create(Veranst:Pointer;AkCollNeu:TAkColl);
//==============================================================================
begin
  inherited Create(Veranst);
  AkRngColl := AkCollNeu;
  FItemSize := SizeOf(TWordCollection);
end;

//==============================================================================
procedure TRngMaxAkColl.RngCollAdd(AkColl:TAkColl);
//==============================================================================
// benutzt in Load, pro Ort leere RngColl's anfügen
var i : Integer;
    C : TWordCollection;
begin
  C := TWordCollection.Create(FVPtr);
  for i:=0 to AkColl.Count-1 do C.Add(0); // Rng=0 für jede Ak
  Self.Addx(C);
end;

//==============================================================================
function TRngMaxAkColl.Addx(Coll:TWordCollection): Integer;
//==============================================================================
var C : TWordCollection;
    i : Integer;
begin
  C := TWordCollection.Create(FVPtr);
  for i:=0 to Coll.Count-1 do C.Add(Coll[i]);
  Result := AddItem(C);
end;


(******************************************************************************)
(*                      Methoden von TWettkObj                                *)
(******************************************************************************)

// protected Methoden

(*----------------------------------------------------------------------------*)
function TWettkObj.GetBPObjType: Word;
(*----------------------------------------------------------------------------*)
(* Object Types aus Version 7.4 Stream Registration Records *)
begin
  Result := rrWettkObj;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetName(NameNeu:String);
(*----------------------------------------------------------------------------*)
begin
  if NameNeu <> FName then
    FName := Trim(NameNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetStreichErg(TlnMsch:TTlnMsch): Integer;
(*----------------------------------------------------------------------------*)
// von 0 (=default) bis OrtZahl-1
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and TVeranstObj(FVPtr).Serie then
    Result := Min(FStreichErg[TlnMsch],TVeranstObj(FVPtr).OrtZahl-1)
  else Result := 0;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetStreichErg(TlnMsch:TTlnMsch; const StreichErgNeu:integer);
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if StreichErgNeu <> GetStreichErg(TlnMsch) then
    begin
      FStreichErg[TlnMsch] := StreichergNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetStreichOrt(TlnMsch:TTlnMsch): Integer;
(*----------------------------------------------------------------------------*)
// von 0 (default, Wertung in allen Orte Pflicht) bis OrtZahl (Liga-Msch, keine MindestWettk)
// StreichOrt = OrtZahl - MindestWettk
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and TVeranstObj(FVPtr).Serie then
    if (TVeranstObj(FVPtr).Art=vaLiga) and (TlnMsch=tmMsch) then
      Result := TVeranstObj(FVPtr).OrtZahl // keine MindestWettk für Liga-Msch
    else Result := Min(FStreichOrt[TlnMsch],TVeranstObj(FVPtr).OrtZahl)
  else Result := 0;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetStreichOrt(TlnMsch:TTlnMsch; const StreichOrtNeu:Integer);
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if StreichOrtNeu <> GetStreichOrt(TlnMsch) then
    begin
      FStreichOrt[TlnMsch] := StreichOrtNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

//------------------------------------------------------------------------------
procedure TWettkObj.SetSerWrtgJahr(const JahrNeu: Integer);
//------------------------------------------------------------------------------
// nur für Altersklassenberechnung bei Serie benutzt
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if JahrNeu <> FSerWrtgJahr then
    begin
      FSerWrtgJahr := JahrNeu;
      if FVPtr = Veranstaltung then SetKlassenModified(true);
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetPflichtWkMode(TlnMsch:TTlnMsch): TPflichtWkMode;
(*----------------------------------------------------------------------------*)
begin
  if (GetStreichErg(TlnMsch) > 0) or (GetStreichOrt(TlnMsch) > 0) then
    Result := FPflichtWkMode[TlnMsch]
  else Result := pw0;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetPflichtWkMode(TlnMsch:TTlnMsch; PflichtWkModeNeu:TPflichtWkMode);
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if PflichtWkModeNeu <> GetPflichtWkMode(TlnMsch) then
    begin
      FPflichtWkMode[TlnMsch] := PflichtWkModeNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetPflichtWkOrt1(TlnMsch:TTlnMsch): TOrtObj;
(*----------------------------------------------------------------------------*)
begin
  if GetPflichtWkMode(TlnMsch) = pw0 then Result := nil //FVPtr in GetPflichtWkMode geprüft
  else Result := FPflichtWkOrt1[TlnMsch];
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetPflichtWkOrt1(TlnMsch:TTlnMsch; OrtNeu:TOrtObj);
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if OrtNeu <> GetPflichtWkOrt1(TlnMsch) then
    begin
      FPflichtWkOrt1[TlnMsch] := OrtNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetPflichtWkOrt1Indx(TlnMsch:TTlnMsch): Integer;
(*----------------------------------------------------------------------------*)
begin
  if GetPflichtWkOrt1(TlnMsch)<>nil then // FVPtr in GetPflichtWkMode geprüft
    Result := TVeranstObj(FVPtr).OrtColl.IndexOf(FPflichtWkOrt1[TlnMsch])
  else Result := -1;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetPflichtWkOrt1Indx(TlnMsch:TTlnMsch; IndxNeu:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (IndxNeu >= 0) and (IndxNeu < TVeranstObj(FVPtr).OrtColl.Count) then
      SetPflichtWkOrt1(TlnMsch,TVeranstObj(FVPtr).OrtColl[IndxNeu])
    else SetPflichtWkOrt1(TlnMsch,nil);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetPflichtWkOrt2(TlnMsch:TTlnMsch): TOrtObj;
(*----------------------------------------------------------------------------*)
begin
  case GetPflichtWkMode(TlnMsch) of //FVPtr,WettkAlleDummy in GetPflichtWkMode geprüft
    pw0,pw1 : Result := nil;
    else Result := FPflichtWkOrt2[TlnMsch]; // pw1v2,pw2
  end;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetPflichtWkOrt2(TlnMsch:TTlnMsch; OrtNeu:TOrtObj);
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if OrtNeu <> GetPflichtWkOrt2(TlnMsch) then
    begin
      FPflichtWkOrt2[TlnMsch] := OrtNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetPflichtWkOrt2Indx(TlnMsch:TTlnMsch): Integer;
(*----------------------------------------------------------------------------*)
begin
  if GetPflichtWkOrt2(TlnMsch)<>nil then //FVPtr,WettkAlleDummy in GetPflichtWkMode geprüft
    Result := TVeranstObj(FVPtr).OrtColl.IndexOf(FPflichtWkOrt2[TlnMsch])
  else Result := -1;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetPflichtWkOrt2Indx(TlnMsch:TTlnMsch; IndxNeu:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (IndxNeu >= 0) and (IndxNeu < TVeranstObj(FVPtr).OrtColl.Count) then
      SetPflichtWkOrt2(TlnMsch,TVeranstObj(FVPtr).OrtColl[IndxNeu])
    else SetPflichtWkOrt2(TlnMsch,nil);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetPunktGleichOrt(TlnMsch:TTlnMsch): TOrtObj;
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and (FPunktGleichOrt[TlnMsch]<>nil) and
     (TVeranstObj(FVPtr).OrtColl.IndexOf(FPunktGleichOrt[TlnMsch]) >= 0) then
    Result := FPunktGleichOrt[TlnMsch]
  else Result := nil;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetPunktGleichOrt(TlnMsch:TTlnMsch; OrtNeu:TOrtObj);
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if OrtNeu <> GetPunktGleichOrt(TlnMsch) then
    begin
      FPunktGleichOrt[TlnMsch] := OrtNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetPunktGleichOrtIndx(TlnMsch:TTlnMsch): Integer;
(*----------------------------------------------------------------------------*)
begin
  if GetPunktGleichOrt(TlnMsch)<>nil then //FVPtr,WettkAlleDummy in GetPunktGleichOrt geprüft
    Result := TVeranstObj(FVPtr).OrtColl.IndexOf(FPunktGleichOrt[TlnMsch])
  else Result := -1;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetPunktGleichOrtIndx(TlnMsch:TTlnMsch; IndxNeu:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (IndxNeu >= 0) and (IndxNeu < TVeranstObj(FVPtr).OrtColl.Count) then
      SetPunktGleichOrt(TlnMsch,TVeranstObj(FVPtr).OrtColl[IndxNeu])
    else SetPunktGleichOrt(TlnMsch,nil);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetMschWertg: TMschWertung;
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr=nil) or (Self=WettkAlleDummy) then
    Result := mwKein
  else
  if TVeranstObj(FVPtr).Art=vaLiga then
    Result := mwEinzel
  else
    Result := FMschWertg
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMschWertg(WertgNeu:TMschWertung);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if WertgNeu <> FMschWertg then
    begin
      FMschWertg := WertgNeu;
      if FVPtr=Veranstaltung then SetMannschModified(true);
    end;
end;

//------------------------------------------------------------------------------
function TWettkObj.GetTlnSerPktMode: TSerPktMode;
//------------------------------------------------------------------------------
begin
  if (FVPtr=nil) or (Self=WettkAlleDummy) then
    Result := spFlexPkt
  else Result := FTlnSerPktMode;
end;

//------------------------------------------------------------------------------
procedure TWettkObj.SetTlnSerPktMode(SerPktModeNeu:TSerPktMode);
//------------------------------------------------------------------------------
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if SerPktModeNeu <> FTlnSerPktMode then
    begin
      FTlnSerPktMode := SerPktModeNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

//------------------------------------------------------------------------------
function TWettkObj.GetMschSerPktMode: TSerPktMode;
//------------------------------------------------------------------------------
begin
  if (FVPtr=nil) or (Self=WettkAlleDummy) then
    Result := spFlexPkt
  else Result := FMschSerPktMode;
end;

//------------------------------------------------------------------------------
procedure TWettkObj.SetMschSerPktMode(SerPktModeNeu:TSerPktMode);
//------------------------------------------------------------------------------
var i : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if SerPktModeNeu <> FMschSerPktMode then
    begin
      FMschSerPktMode := SerPktModeNeu;
      if FVPtr=Veranstaltung then
        for i:=0 to Veranstaltung.OrtZahl-1 do
          if Veranstaltung.TlnColl.OrtTlnEingeteilt(i,Self)>0 then
            SetOrtErgmodified(i,true);
    end;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetKlassenModified(ModifiedNeu:Boolean);
(*----------------------------------------------------------------------------*)
// wenn true werden alle Modifieds gesetzt
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
  begin
    FKlassenModified := ModifiedNeu;
    if ModifiedNeu and (FVPtr=Veranstaltung) then
      SetMannschModified(true);// auch ErgModified für alle Orte
  end;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMannschModified(ModifiedNeu:Boolean);
(*----------------------------------------------------------------------------*)
// alle Mannschaften werden gelöscht und neu eingelesen (MschEinlesen in TlnErg aufgerufen)
// Wertungen für alle Orte neu berechnen
// Staffelvorg müssen neu definiert und
// MschStartzeiten neu berechnet werden.
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
  begin
    FMannschModified := ModifiedNeu;
    if ModifiedNeu and (FVPtr=Veranstaltung) then
      SetOrtErgModified(-1,true);
  end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetErgModified: Boolean;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtErgModified(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtErgModified(-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtErgModified(Indx:Integer): Boolean;
(*----------------------------------------------------------------------------*)
var i: Integer;
begin
  Result := false;
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
      Result := FErgModifiedColl[Indx]
    else if Indx=-1 then // über alle Orte prüfen
      for i:=0 to FErgModifiedColl.Count-1 do
        if FErgModifiedColl[i] then
        begin
          Result := true;
          Exit;
        end;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetErgModified(ModifiedNeu:Boolean);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtErgModified(TVeranstObj(FVPtr).OrtIndex,ModifiedNeu);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtErgModified(Indx:Integer; ModifiedNeu:Boolean);
(*----------------------------------------------------------------------------*)
var i,Min,Max : Integer;
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
  begin
    if Indx=-1 then begin Min := 0; Max := TVeranstObj(FVPtr).OrtZahl-1; end
               else begin Min := Indx; Max:=Indx; end;
    for i:=Min to Max do
      FErgModifiedColl[i] := ModifiedNeu;
    if ModifiedNeu then Rechnen := true;
  end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtStandTitel(Indx:Integer): String;
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    Result := FStandTitelColl[Indx]
  else Result := '';
  if Result = '' then Result := FName;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetStandTitel: String;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtStandTitel(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtStandTitel(-1);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtStandTitel(Indx:Integer; StandTitelNeu:String);
(*----------------------------------------------------------------------------*)
// StandTitel niemals ''
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy)  and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    FStandTitelColl[Indx] := Trim(StandTitelNeu);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetStandTitel(StandTitelNeu:String);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtStandTitel(TVeranstObj(FVPtr).OrtIndex,StandTitelNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetSondWrtg: Boolean;
(*----------------------------------------------------------------------------*)
begin
  Result := not StrGleich(GetSondTitel,'');
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetSondTitel: String;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtSondTitel(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtSondTitel(-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtSondTitel(Indx:Integer): String;
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    Result := FSondTitelColl[Indx]
  else Result := '';
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetSondTitel(SondTitelNeu:String);
(*----------------------------------------------------------------------------*)
// SondTitel = '', wenn keine Sonderwertung definiert wurde
begin
  if FVPtr<>nil then
    SetOrtSondTitel(TVeranstObj(FVPtr).OrtIndex,SondTitelNeu);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtSondTitel(Indx:Integer; SondTitelNeu:String);
(*----------------------------------------------------------------------------*)
// SondTitel = '', wenn keine Sonderwertung definiert wurde
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    FSondTitelColl[Indx] := Trim(SondTitelNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetDatum: String;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtDatum(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtDatum(-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtDatum(Indx:Integer): String;
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    if Self <> WettkAlleDummy then
      Result := FDatumColl[Indx]
    else
    if (FVPtr=Veranstaltung) and (Veranstaltung.WettkColl.Count > 0) then
      Result := Veranstaltung.WettkColl[0].OrtDatum[Indx]
    else
      Result := SystemDatum
  else Result := SystemDatum;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtDatum(Indx:Integer; const DatumNeu: String);
(*----------------------------------------------------------------------------*)
var S : String;
begin
  S := DatumStr(DatumNeu); // Trennzeichen ignorieren
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
     (DatumWert(S) > 0) and (FDatumColl[Indx] <> S) then
  begin
    FDatumColl[Indx] := S;
    if FVPtr = Veranstaltung then
      if Veranstaltung.Serie then // bei Serie SerWrtgJahr bestimmend für Ak
        if FSerWrtgJahr = 0 then SetSerWrtgJahr(GetOrtJahr(Indx)) // KlassenModified gesetzt
        else
      else SetKlassenModified(true); // bei EinzelWettk Datum für Ak bestimmend
  end;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetDatum(const DatumNeu: String);
(*----------------------------------------------------------------------------*)
// datum niemals ''
begin
  if FVPtr<>nil then
    SetOrtDatum(TVeranstObj(FVPtr).OrtIndex,DatumNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtJahr(Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    Result := StrToIntDef(Copy(GetOrtDatum(Indx),7,4),0)
  else Result := 0;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetJahr: Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtJahr(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtJahr(-1);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetTlnMKlasse(AkNeu:TAkObj);
(*----------------------------------------------------------------------------*)
// nur Name ändern
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    FTlnMKlasse.Name := Trim(AkNeu.Name);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetTlnWKlasse(AkNeu:TAkObj);
(*----------------------------------------------------------------------------*)
// nur Name ändern
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    FTlnWKlasse.Name := Trim(AkNeu.Name);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMschMKlasse(AkNeu:TAkObj);
(*----------------------------------------------------------------------------*)
// nur Name ändern
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    FMschMKlasse.Name := Trim(AkNeu.Name);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMschWKlasse(AkNeu:TAkObj);
(*----------------------------------------------------------------------------*)
// nur Name ändern
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    FMschWKlasse.Name := Trim(AkNeu.Name);
end;

{(*----------------------------------------------------------------------------*)
function TWettkObj.GetTlnAltMKlasseColl: TAkColl;
(*----------------------------------------------------------------------------*)
begin
  Result := FTlnAltMKlasseColl
end;}

{(*----------------------------------------------------------------------------*)
function TWettkObj.GetTlnAltWKlasseColl: TAkColl;
(*----------------------------------------------------------------------------*)
begin
  Result := FTlnAltWKlasseColl;
end;}

{(*----------------------------------------------------------------------------*)
function TWettkObj.GetTlnSondMKlasseColl: TAkColl;
(*----------------------------------------------------------------------------*)
begin
  Result := FTlnSondMKlasseColl;
end;}

{(*----------------------------------------------------------------------------*)
function TWettkObj.GetTlnSondWKlasseColl: TAkColl;
(*----------------------------------------------------------------------------*)
begin
  Result := FTlnSondWKlasseColl;
end; }

(*----------------------------------------------------------------------------*)
function TWettkObj.GetWettkArt: TWettkArt;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtWettkArt(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtWettkArt(-1);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetWettkArt(WkArtNeu:TWettkArt);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtWettkArt(TVeranstObj(FVPtr).OrtIndex,WkArtNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtWettkArt(Indx:Integer): TWettkArt;
(*----------------------------------------------------------------------------*)
// waTlnStaffel nicht bei Serie
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
  begin
    if FWettkArtColl <> nil then
      case FWettkArtColl[Indx] of
        1: Result := waMschStaffel;
        2: Result := waMschTeam;
        //3:   Result := waMschSchopfheim; // ab 2005 nicht mehr unterstützt
        //3,4:   Result := waMschSigmaringen; // beide werte benutzt (4=alt)!
        5: if not TVeranstObj(FVPtr).Serie then Result := waTlnStaffel
                                           else Result := waEinzel;
        6: Result := waRndRennen;
        else Result := waEinzel; //waInt3,waInt4
      end
    else Result := waEinzel
  end
  else Result := waEinzel;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtWettkArt(Indx:Integer; WkArtNeu:TWettkArt);
(*----------------------------------------------------------------------------*)
// WkArt: [waEinzel,waMschStaffel,waMschTeam,waInt3,waInt4,waTlnStaffel,waRndRennen]
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
       (Integer(WkArtNeu) <> FWettkArtColl[Indx]) then
    begin
      FWettkArtColl[Indx] := Integer(WkArtNeu);
      if FVPtr=Veranstaltung then SetMannschModified(true); // weil impact auf MschEinlesen
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetMschWrtgMode: TMschWrtgMode;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtMschWrtgMode(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtMschWrtgMode(-1);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMschWrtgMode(MschWrtgModeNeu:TMschWrtgMode);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtMschWrtgMode(TVeranstObj(FVPtr).OrtIndex,MschWrtgModeNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtMschWrtgMode(Indx:Integer): TMschWrtgMode;
(*----------------------------------------------------------------------------*)
begin
  Result := wmTlnZeit;
  if (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
     (FMschWrtgModeColl <> nil) and (GetMschWertg <> mwKein) then
    if FMschWrtgModeColl[Indx] = Integer(wmTlnPlatz) then
      Result := wmTlnPlatz
    else if ((GetMschWertg = mwEinzel)) and
             (FMschWrtgModeColl[Indx] = Integer(wmSchultour)) then
      Result := wmSchultour;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtMschWrtgMode(Indx:Integer; MschWrtgModeNeu:TMschWrtgMode);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
     (Integer(MschWrtgModeNeu) <> FMschWrtgModeColl[Indx]) then
  begin
    FMschWrtgModeColl[Indx] := Integer(MschWrtgModeNeu);
    if FVPtr=Veranstaltung then SetMannschModified(true); // weil impact auf MschEinlesen
  end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetMannschGrAnm: Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtMannschGrAnm(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtMannschGrAnm(-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtMannschGrAnm(Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
begin
  Result := 0;
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if TVeranstObj(FVPtr).Art <> vaLiga then Result := cnTlnMax
    else
    if (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
      Result := Max(0,FMannschGrAnmColl[Indx]);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMannschGrAnm(Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtMannschGrAnm(TVeranstObj(FVPtr).OrtIndex,Groesse);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtMannschGrAnm(Indx:Integer; Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
       (FMannschGrAnmColl[Indx] <> Max(Groesse,0)) then
    begin
      FMannschGrAnmColl[Indx] := Max(Groesse,0);
      if FVPtr=Veranstaltung then SetMannschModified(true);
    end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetMannschGrStrt: Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtMannschGrStrt(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtMannschGrStrt(-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtMannschGrStrt(Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
begin
  Result := 0;
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if TVeranstObj(FVPtr).Art <> vaLiga then Result := cnTlnMax
    else
    if (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
      Result := Max(0,FMannschGrStrtColl[Indx]);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMannschGrStrt(Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtMannschGrStrt(TVeranstObj(FVPtr).OrtIndex,Groesse);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtMannschGrStrt(Indx:Integer; Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
       (FMannschGrStrtColl[Indx] <> Max(Groesse,0)) then
    begin
      FMannschGrStrtColl[Indx] := Max(Groesse,0);
      if FVPtr=Veranstaltung then SetMannschModified(true);
    end;
end;
{
(*----------------------------------------------------------------------------*)
function TWettkObj.GetMannschGrWrtg: Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtMannschGrWrtg(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtMannschGrWrtg(-1)
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtMannschGrWrtg(Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
var i : Integer;
//..............................................................................
function OrtWkMannschGrWrtg(Wk:TWettkObj): Integer;
begin
  with Wk do
   if GetOrtWettkArt(Indx) <> waTlnStaffel then
      Result := FMannschGrWrtgColl[Indx]
    else
      Result := GetOrtAbschnZahl(Indx);
end;
//..............................................................................
begin
  Result := 0;
  if (FVPtr<>nil) and (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    if (Self=WettkAlleDummy) and (FVPtr=Veranstaltung) then
      // Max. für alle Wettkämpfe, für RaveReports über Alle Wettk
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        if Result < OrtWkMannschGrWrtg(Veranstaltung.WettkColl[i]) then
          Result := OrtWkMannschGrWrtg(Veranstaltung.WettkColl[i])
        else
    else
      Result := OrtWkMannschGrWrtg(Self);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMannschGrWrtg(Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtMannschGrWrtg(TVeranstObj(FVPtr).OrtIndex,Groesse);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtMannschGrWrtg(Indx:Integer; Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) then
    if (FMannschGrWrtgColl[Indx] <> Max(Groesse,0)) and
       (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    begin
      FMannschGrWrtgColl[Indx] := Max(Groesse,0);
      if FVPtr=Veranstaltung then SetMannschModified(true);
    end;
end;
}
(*----------------------------------------------------------------------------*)
function TWettkObj.GetMschGroesse(Sx:TSex): Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtMschGroesse(Sx,TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtMschGroesse(Sx,-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtMschGroesse(Sx:TSex;Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
var i : Integer;
//..............................................................................
function OrtWkMschGroesse(Sx:TSex;Wk:TWettkObj): Integer;
begin
  with Wk do
    if GetOrtWettkArt(Indx) <> waTlnStaffel then
      case Sx of
        cnMaennlich : Result := FMschGrMaennerColl[Indx];
        cnWeiblich  : Result := FMschGrFrauenColl[Indx];
        cnMixed     : Result := FMschGrMixedColl[Indx];
        cnSexBeide  : Result := FMschGrAlleColl[Indx];
        else          Result := 0;
      end
    else
      Result := GetOrtAbschnZahl(Indx);
end;
//..............................................................................
begin
  Result := 0;
  if (FVPtr<>nil) and (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
     ((TVeranstObj(FVPtr).Art <> vaLiga) or (Sx = cnSexBeide)) then
    if (Self=WettkAlleDummy) and (FVPtr=Veranstaltung) then
      // Max. für alle Wettkämpfe, für RaveReports über Alle Wettk
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        if Result < OrtWkMschGroesse(Sx,Veranstaltung.WettkColl[i]) then
          Result := OrtWkMschGroesse(Sx,Veranstaltung.WettkColl[i])
        else
    else
      Result := OrtWkMschGroesse(Sx,Self);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetMschGroesse(Sx:TSex;Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtMschGroesse(Sx,TVeranstObj(FVPtr).OrtIndex,Groesse);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtMschGroesse(Sx:TSex;Indx:Integer; Groesse:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil) and (Self<>WettkAlleDummy) and
     (Indx >= 0) and (Indx < TVeranstObj(FVPtr).OrtZahl) then
  begin
    if (Groesse < cnMschGrMin) or (Groesse > cnMschGrMax) then
      Groesse := cnMschGrDefault;
    case Sx of
      cnMaennlich:
        if FMschGrMaennerColl[Indx] <> Groesse then
        begin
          FMschGrMaennerColl[Indx] := Groesse;
          if FVPtr=Veranstaltung then SetMannschModified(true);
        end;
      cnWeiblich:
        if FMschGrFrauenColl[Indx] <> Groesse then
        begin
          FMschGrFrauenColl[Indx] := Groesse;
          if FVPtr=Veranstaltung then SetMannschModified(true);
        end;
      cnMixed:
        if FMschGrMixedColl[Indx] <> Groesse then
        begin
          FMschGrMixedColl[Indx] := Groesse;
          if FVPtr=Veranstaltung then SetMannschModified(true);
        end;
      cnSexBeide:
        if FMschGrAlleColl[Indx] <> Groesse then
        begin
          FMschGrAlleColl[Indx] := Groesse;
          if FVPtr=Veranstaltung then SetMannschModified(true);
        end;
      cnKeinSex: ;
    end;
  end;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetSchwimmDistanz: Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtSchwimmDistanz(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtSchwimmDistanz(-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtSchwimmDistanz(Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil) and (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    if (Self=WettkAlleDummy) and (FVPtr=Veranstaltung) then // Max Wert für Rave Reports
    begin
      Result := 0;
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        Result := Max(Result,Veranstaltung.WettkColl[i].SchwimmDistanzColl[Indx]);
    end
    else Result := SchwimmDistanzColl[Indx]
  else Result := 0;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetSchwimmDistanz(SchwimmDistanz:Integer);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtSchwimmDistanz(TVeranstObj(FVPtr).OrtIndex,SchwimmDistanz );
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtSchwimmDistanz(Indx:Integer; SchwimmDistanz:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    FSchwimmDistanzColl[Indx] := SchwimmDistanz;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetStartBahnen: Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtStartBahnen(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtStartBahnen(-1);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtStartBahnen(Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  if (FVPtr<>nil) and (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    if (Self=WettkAlleDummy) and (FVPtr=Veranstaltung) then //Max Wert für Rave Repotrs
    begin
      Result := 0;
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        with Veranstaltung.WettkColl[i] do
          if FStartBahnenColl[Indx] > Result
            then Result := FStartBahnenColl[Indx];
    end
    else Result := FStartBahnenColl[Indx]
  else Result := 0;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetStartBahnen(StartBahnen:Integer);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtStartBahnen(TVeranstObj(FVPtr).OrtIndex,StartBahnen);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtStartBahnen(Indx:Integer; StartBahnen:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    FStartBahnenColl[Indx] := StartBahnen;
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetAbschnZahl: Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtAbschnZahl(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtAbschnZahl(-1);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetAbschnZahl(ZahlNeu:Integer);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtAbschnZahl(TVeranstObj(FVPtr).OrtIndex,ZahlNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtAbschnZahl(Indx:Integer): Integer;
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  Result := 1;
  if (FVPtr<>nil) and (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    if (Self=WettkAlleDummy) and (FVPtr=Veranstaltung) then
      for i := 0 to Veranstaltung.WettkColl.Count-1 do
        Result := Max(Result,Veranstaltung.WettkColl[i].FAbschnZahlColl[Indx])
    else Result := Max(1,FAbschnZahlColl[Indx]);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtAbschnZahl(Indx,ZahlNeu:Integer);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) and
     (FAbschnZahlColl[Indx] <> ZahlNeu) then
  begin
    FAbschnZahlColl[Indx] := Max(1,ZahlNeu);
    if FVPtr=Veranstaltung then SetOrtErgModified(Indx,true);
  end;
end;

//------------------------------------------------------------------------------
function TWettkObj.GetAbschnNameColl(Abschnitt:TWkAbschnitt): TTextCollection;
//------------------------------------------------------------------------------
begin
  Result := FAbschnNameCollArr[Abschnitt];
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetAbschnName(Abschnitt:TWkAbschnitt): String;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtAbschnName(TVeranstObj(FVPtr).OrtIndex,Abschnitt)
  else Result := GetOrtAbschnName(-1,Abschnitt);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetAbschnName(Abschnitt:TWkAbschnitt;NameNeu:String);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtAbschnName(TVeranstObj(FVPtr).OrtIndex,Abschnitt,NameNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtAbschnName(Indx:Integer;Abschnitt:TWkAbschnitt): String;
(*----------------------------------------------------------------------------*)
var i : Integer;
begin
  Result := ''; // gilt bei AbschnZahl=1
  if (FVPtr<>nil) and
     (Indx >= 0) and (Indx < TVeranstObj(FVPtr).OrtZahl) and
     (GetOrtAbschnZahl(Indx)>1)and(Integer(Abschnitt)<=GetOrtAbschnZahl(Indx)) then

    if (Self<>WettkAlleDummy) or (FVPtr<>Veranstaltung)then
      Result := GetAbschnNameColl(Abschnitt)[Indx]
    else
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        if Result = '' then
          Result := Veranstaltung.WettkColl[i].GetAbschnNameColl(Abschnitt)[Indx]
        else if Result<>Veranstaltung.WettkColl[i].GetAbschnNameColl(Abschnitt)[Indx] then
        begin
          Result := 'Abs. ' + IntToStr(Integer(Abschnitt));
          Exit;
        end;
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtAbschnName(Indx:Integer;Abschnitt:TWkAbschnitt;NameNeu:String);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx >= 0) and (Indx < TVeranstObj(FVPtr).OrtZahl) then
    FAbschnNameCollArr[Abschnitt][Indx] := Trim(NameNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetTlnTxt: String;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtTlnTxt(TVeranstObj(FVPtr).OrtIndex)
  else Result := GetOrtTlnTxt(-1);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetTlnTxt(TxtNeu:String);
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    SetOrtTlnTxt(TVeranstObj(FVPtr).OrtIndex,TxtNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtTlnTxt(Indx:Integer): String;
(*----------------------------------------------------------------------------*)
var i : Integer;
    TxtVorhanden   : Boolean;
    TxtUnterschied : Boolean;
    S : String;
begin
  if (FVPtr<>nil) and (Indx>=0) and
     (Indx<TVeranstObj(FVPtr).OrtZahl) and (FCollection<>nil) then
    if (Self<>WettkAlleDummy) or (FVPtr<>Veranstaltung) then
      Result := FTlnTxtColl[Indx]
    else // bei WettkAlleDummy gilt 'Opt' oder TlnTxt (nur AnmeldeAnsicht)
    begin
      TxtVorhanden   := false;
      TxtUnterschied := false;
      S := '';
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        if not StrGleich(Veranstaltung.WettkColl[i].OrtTlnTxt[Indx],'') then
        begin
          TxtVorhanden := true;
          if not StrGleich(S,'') and
             not StrGleich(S,Veranstaltung.WettkColl[i].OrtTlnTxt[Indx]) then
               TxtUnterschied := true;
          S := Veranstaltung.WettkColl[i].OrtTlnTxt[Indx];
        end;
      if TxtVorhanden then
        if TxtUnterschied then Result := 'Opt.'
                          else Result := S
      else Result := '';
    end
  else Result := '';
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetOrtTlnTxt(Indx:Integer;TxtNeu:String);
(*----------------------------------------------------------------------------*)
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    FTlnTxtColl[Indx] := Trim(TxtNeu);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetAbschnRunden(Abschnitt:TWkAbschnitt): Integer;
(*----------------------------------------------------------------------------*)
begin
  if FVPtr<>nil then
    Result := GetOrtAbschnRunden(TVeranstObj(FVPtr).OrtIndex,Abschnitt)
  else Result := GetOrtAbschnRunden(-1,Abschnitt);
end;

(*----------------------------------------------------------------------------*)
function TWettkObj.GetOrtAbschnRunden(Indx:Integer;Abschnitt:TWkAbschnitt): Integer;
(*----------------------------------------------------------------------------*)
// Min = 1
var i : Integer;
begin
  Result := 1;
  if (FVPtr<>nil) and
     (Indx >= 0) and (Indx < TVeranstObj(FVPtr).OrtZahl) then
    if (Self<>WettkAlleDummy) or (FVPtr<>Veranstaltung) then
      Result := Max(1,FAbschnRundCollArr[Abschnitt][Indx])
    else
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        Result := Max(Result,Veranstaltung.WettkColl[i].FAbschnRundCollArr[Abschnitt][Indx]);
end;

(*----------------------------------------------------------------------------*)
procedure TWettkObj.SetAbschnRunden(Abschnitt:TWkAbschnitt;RundenNeu:Integer);
(*----------------------------------------------------------------------------*)
// Min = 1
begin
  if (FVPtr<>nil)and(Self<>WettkAlleDummy) and // nicht beim Laden
     (FAbschnRundCollArr[Abschnitt][TVeranstObj(FVPtr).OrtIndex] <> Max(1,RundenNeu)) then
  begin
    FAbschnRundCollArr[Abschnitt][TVeranstObj(FVPtr).OrtIndex]:= Max(1,RundenNeu);
    if FVPtr=Veranstaltung then
    begin
      Veranstaltung.TlnColl.UpdateRundenZahl(Abschnitt,Self);
      SetErgModified(true);
    end;
  end;
end;


// public Methoden

(*============================================================================*)
constructor TWettkObj.Create(Veranst:Pointer;Coll:TTriaObjColl;Add:TOrtAdd);
(*============================================================================*)
var i: Integer;
    R: TCupWrtgPktRec;
    AbsCnt : TWkAbschnitt;
    TlnMsch : TTlnMsch;
begin
  inherited Create(Veranst,Coll,Add);
  FName := '';
  for TlnMsch:=tmTln to tmMsch do
  begin
    FStreichErg[TlnMsch]     := 0;
    FStreichOrt[TlnMsch]     := 0;
    FPflichtWkMode[TlnMsch]  := pw0;
    FPflichtWkOrt1[TlnMsch]  := nil;
    FPflichtWkOrt2[TlnMsch]  := nil;
    FPunktGleichOrt[TlnMsch] := nil;
  end;
  FMannschModified := false;
  FKlassenModified := false;
  FMschWertg       := mwEinzel;  // DefaultMschWertg;
  FTlnSerPktMode   := spFlexPkt; // default
  FMschSerPktMode  := spFlexPkt; // default
  FTlnMKlasse      := TAkObj.Create(nil,nil,oaAdd);
  FTlnWKlasse      := TAkObj.Create(nil,nil,oaAdd);
  FMschMKlasse     := TAkObj.Create(nil,nil,oaAdd);
  FMschWKlasse     := TAkObj.Create(nil,nil,oaAdd);
  with AkMaenner do FTlnMKlasse.Init(Name,Kuerzel,AlterVon,AlterBis,Sex,Wertung);
  with AkFrauen do FTlnWKlasse.Init(Name,Kuerzel,AlterVon,AlterBis,Sex,Wertung);
  with AkMaenner do FMschMKlasse.Init(Name,Kuerzel,AlterVon,AlterBis,Sex,Wertung);
  with AkFrauen do FMschWKlasse.Init(Name,Kuerzel,AlterVon,AlterBis,Sex,Wertung);

  FStandTitelColl     := TTextCollection.Create(FVPtr);
  FSondTitelColl      := TTextCollection.Create(FVPtr);
  FDatumColl          := TTextCollection.Create(FVPtr);
  FWettkArtColl       := TWordCollection.Create(FVPtr);
  FMschWrtgModeColl   := TWordCollection.Create(FVPtr);
  FMannschGrAnmColl   := TWordCollection.Create(FVPtr);
  FMannschGrStrtColl  := TWordCollection.Create(FVPtr);
  FMschGrAlleColl     := TWordCollection.Create(FVPtr);
  FMschGrMaennerColl  := TWordCollection.Create(FVPtr);
  FMschGrFrauenColl   := TWordCollection.Create(FVPtr);
  FMschGrMixedColl    := TWordCollection.Create(FVPtr);
  FSchwimmDistanzColl := TWordCollection.Create(FVPtr);
  FStartBahnenColl    := TWordCollection.Create(FVPtr);
  FErgModifiedColl    := TBoolCollection.Create(FVPtr);
  FAbschnZahlColl     := TWordCollection.Create(FVPtr);

  for AbsCnt:=wkAbs1 to wkAbs8 do
  begin
    FAbschnNameCollArr[AbsCnt] := TTextCollection.Create(FVPtr);
    FAbschnRundCollArr[AbsCnt] := TWordCollection.Create(FVPtr);
  end;

  FTlnTxtColl         := TTextCollection.Create(FVPtr);
  TlnImZielColl       := TBoolCollection.Create(FVPtr);
  RngBuffColl         := TIntSortCollection.Create(FVPtr);

  TlnAltMKlasseColl  := TAkColl.Create(FVPtr,SystemJahr,kwAltKl,cnMaennlich);
  TlnSondMKlasseColl := TAkColl.Create(FVPtr,SystemJahr,kwSondKl,cnMaennlich);
  MschAltMKlasseColl := TAkColl.Create(FVPtr,SystemJahr,kwAltKl,cnMaennlich);
  TlnAltWKlasseColl  := TAkColl.Create(FVPtr,SystemJahr,kwAltKl,cnWeiblich);
  TlnSondWKlasseColl := TAkColl.Create(FVPtr,SystemJahr,kwSondKl,cnWeiblich);
  MschAltWKlasseColl := TAkColl.Create(FVPtr,SystemJahr,kwAltKl,cnWeiblich);

  FRngMaxTlnAlleColl     := TWordCollection.Create(FVPtr);
  FRngMaxTlnMaennerColl  := TWordCollection.Create(FVPtr);
  FRngMaxTlnFrauenColl   := TWordCollection.Create(FVPtr);
  FRngMaxMschAlleColl    := TWordCollection.Create(FVPtr);
  FRngMaxMschMaennerColl := TWordCollection.Create(FVPtr);
  FRngMaxMschFrauenColl  := TWordCollection.Create(FVPtr);
  FRngMaxMschMixedColl   := TWordCollection.Create(FVPtr);

  FRngMaxTlnAkMColl      := TRngMaxAkColl.Create(FVPtr,TlnAltMKlasseColl);
  FRngMaxTlnSkMColl      := TRngMaxAkColl.Create(FVPtr,TlnSondMKlasseColl);
  FRngMaxMschAkMColl     := TRngMaxAkColl.Create(FVPtr,MschAltMKlasseColl);
  FRngMaxTlnAkWColl      := TRngMaxAkColl.Create(FVPtr,TlnAltWKlasseColl);
  FRngMaxTlnSkWColl      := TRngMaxAkColl.Create(FVPtr,TlnSondWKlasseColl);
  FRngMaxMschAkWColl     := TRngMaxAkColl.Create(FVPtr,MschAltWKlasseColl);

  // Init CupWrtgColl nach LBS-Nachwuchscup
  R.RngVon  := 1;
  R.RngBis  := cnTlnMax;
  R.PktVon  := 1;
  R.PktIncr := 1;
  FTlnCupWrtgPktColl := TCupWrtgPktColl.Create(FVPtr);
  FTlnCupWrtgPktColl.Add(R);
  FMschCupWrtgPktColl := TCupWrtgPktColl.Create(FVPtr);
  FMschCupWrtgPktColl.Add(R);

  OrtZahlGestartet := 0; // benutzt und gesetzt bei Seriewertung
  TlnAkZahlMax     := 0; // für Ergebnisse Berechnen
  MschAkZahlMax    := 0; // für Ergebnisse Berechnen
  FSerWrtgJahr     := 0; // nur für Altersberechnung Serienwertung

  if (Add=oaAdd) and (FVPtr<>nil) then
    for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do OrtCollAdd;
end;

(*============================================================================*)
destructor TWettkObj.Destroy;
(*============================================================================*)
var AbsCnt : TWkAbschnitt;
begin
  // Collections löschen
  FreeAndNil(FStandTitelColl);
  FreeAndNil(FSondTitelColl);
  FreeAndNil(FDatumColl);
  FreeAndNil(FWettkArtColl);
  FreeAndNil(FMschWrtgModeColl);
  FreeAndNil(FMannschGrAnmColl);
  FreeAndNil(FMannschGrStrtColl);
  FreeAndNil(FMschGrAlleColl);
  FreeAndNil(FMschGrMaennerColl);
  FreeAndNil(FMschGrFrauenColl);
  FreeAndNil(FMschGrMixedColl);
  FreeAndNil(FSchwimmDistanzColl);
  FreeAndNil(FStartBahnenColl);
  FreeAndNil(FErgModifiedColl);
  FreeAndNil(FAbschnZahlColl);
  for AbsCnt:=wkAbs1 to wkAbs8 do
  begin
    FreeAndNil(FAbschnNameCollArr[AbsCnt]);
    FreeAndNil(FAbschnRundCollArr[AbsCnt]);
  end;
  FreeAndNil(FRngMaxTlnAlleColl);
  FreeAndNil(FRngMaxTlnMaennerColl);
  FreeAndNil(FRngMaxTlnFrauenColl);
  FreeAndNil(FRngMaxMschAlleColl);
  FreeAndNil(FRngMaxMschMaennerColl);
  FreeAndNil(FRngMaxMschFrauenColl);
  FreeAndNil(FRngMaxMschMixedColl);
  FreeAndNil(FRngMaxTlnAkMColl);
  FreeAndNil(FRngMaxTlnSkMColl);
  FreeAndNil(FRngMaxMschAkMColl);
  FreeAndNil(FRngMaxTlnAkWColl);
  FreeAndNil(FRngMaxTlnSkWColl);
  FreeAndNil(FRngMaxMschAkWColl);
  FreeAndNil(FTlnTxtColl);
  FreeAndNil(TlnImZielColl);
  FreeAndNil(RngBuffColl);
  FreeAndNil(TlnAltMKlasseColl);
  FreeAndNil(TlnSondMKlasseColl);
  FreeAndNil(MschAltMKlasseColl);
  FreeAndNil(TlnAltWKlasseColl);
  FreeAndNil(TlnSondWKlasseColl);
  FreeAndNil(MschAltWKlasseColl);
  FreeAndNil(FTlnCupWrtgPktColl);
  FreeAndNil(FMschCupWrtgPktColl);

  inherited Destroy;
end;

(*============================================================================*)
function TWettkObj.Load: Boolean;
(*============================================================================*)
var i,j             : Integer;
    MschWrtgBuf,
    AkWrtgBuf,
    WordBuf         : Word;
    Buff,
    C,CollCnt,
    AkMinBuff,
    AkMaxBuff       : SmallInt;
    SBuff           : String;
    LBuff           : LongInt;
    DummyKlasseColl : TAkColl;
    AbsCnt          : TWkAbschnitt;

begin
  Result := false;

  with TriaStream do
  try
    if FVPtr <> EinlVeranst then Exit;
    if not inherited Load then Exit;

    if (TriDatei.Version.Jahr>'2004')or
       (TriDatei.Version.Jahr='2004')and(TriDatei.Version.Nr>='1.1') then
    begin
      // read allg Strings
      ReadBuffer(C,cnSizeOfSmallInt);
      for i:=0 to C-1 do
        case i of
          0: ReadStr(FName);      // Str 1
          1: ReadStr(SBuff);      // Str 2, Dummy für FLigaKuerzel, ab 2010
          2: begin ReadStr(SBuff);FTlnMKlasse.Name :=SBuff; end;// Str 3 2005
          3: begin ReadStr(SBuff);FTlnWKlasse.Name :=SBuff; end;// Str 4
          4: begin ReadStr(SBuff);FMschMKlasse.Name:=SBuff; end;// Str 5
          5: begin ReadStr(SBuff);FMschWKlasse.Name:=SBuff; end;// Str 6
          else ReadStr(SBuff);           // zukünftige Erweiterungen
        end;
      // read allg SmallInt
      ReadBuffer(C,cnSizeOfSmallInt);
      for i:=0 to C-1 do
        case i of
          0: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 1
               {case Buff of
                 0: FTlnGesWertg := gwAlleAk;
                 1: FTlnGesWertg := gwMannFrau;
                 2: FTlnGesWertg := gwProAk;
               end;}
             end;
          1: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 2
               case Buff of
                 0: FMschWertg := mwKein;
                 1: FMschWertg := mwEinzel;
                 2: FMschWertg := mwMulti;
               end;
             end;
          2: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 3
               {case Buff of
                 0: FMschGesWertg := gwAlleAk;
                 1: FMschGesWertg := gwMannFrau;
                 2: FMschGesWertg := gwProAk;
               end; }
             end;
          3: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 4
               FStreichErg[tmTln] := Buff;
             end;
          4: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 5
               SetPunktGleichOrtIndx(tmTln,Buff);
             end;
          5: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 6
               FPflichtWkMode[tmTln] := TPflichtWkMode(Buff);
             end;
          6: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 7
               SetPflichtWkOrt1Indx(tmTln,Buff);
             end;
          7: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 8
               SetPflichtWkOrt2Indx(tmTln,Buff);
             end;
          8: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 9
               FStreichOrt[tmTln] := Buff;
             end;
          9: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 10
               FStreichErg[tmMsch] := Buff;
             end;
         10: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 11
               SetPunktGleichOrtIndx(tmMsch,Buff);
             end;
         11: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 12
               FPflichtWkMode[tmMsch] := TPflichtWkMode(Buff);
             end;
         12: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 13
               SetPflichtWkOrt1Indx(tmMsch,Buff);
             end;
         13: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 14
               SetPflichtWkOrt2Indx(tmMsch,Buff);
             end;
         14: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 15
               FStreichOrt[tmMsch] := Buff;
             end;
         15: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 16 - ab 11.1.4
               SetSerWrtgJahr(Buff);
             end;
         16: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 17 - ab 11.2.4
               case Buff of
                 1: FTlnSerPktMode := spRngUpPkt;
                 2: FTlnSerPktMode := spRngDownPkt;
                 else FTlnSerPktMode := spFlexPkt;
               end;
             end;
         17: begin
               ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 18 - ab 11.2.4
               case Buff of
                 1: FMschSerPktMode := spRngUpPkt;
                 2: FMschSerPktMode := spRngDownPkt;
                 else FMschSerPktMode := spFlexPkt; // default
               end;
             end;
          else ReadBuffer(Buff,cnSizeOfSmallInt);      // zukunft
        end;

      // read allg LongInt
      ReadBuffer(C,cnSizeOfSmallInt);
      for i:=0 to C-1 do ReadBuffer(LBuff,cnSizeOfLongInt);  // zukunft

      // load 6x KlasseColl
      DummyKlasseColl := TAkColl.Create(FVPtr,0,kwAltKl,cnMaennlich);
      ReadBuffer(C,cnSizeOfSmallInt);
      for i:=0 to C-1 do
        case i of
          0: if not TlnAltMKlasseColl.Load then Exit;
          1: if not TlnSondMKlasseColl.Load then Exit;
          2: if not MschAltMKlasseColl.Load then Exit;
          3: if not TlnAltWKlasseColl.Load then Exit;
          4: if not TlnSondWKlasseColl.Load then Exit;
          5: if not MschAltWKlasseColl.Load then Exit;
          else if not DummyKlasseColl.Load then Exit; // Clear in AkObj
        end;
      DummyKlasseColl.Free;

      // load Ort Collections, momentan nur pro Ort
      ReadBuffer(CollCnt,cnSizeOfSmallInt);
      for i:=0 to CollCnt-1 do
      begin
        // read Strings pro Ort in Coll
        ReadBuffer(C,cnSizeOfSmallInt);
        for j:=0 to C-1 do
          if i < TVeranstObj(FVPtr).OrtZahl then
            case j of
              0: begin
                   ReadStr(SBuff);
                   FStandTitelColl.Add(SBuff);  // Str 1
                 end;
              1: begin
                   ReadStr(SBuff); // Trennzeichen ignorieren
                   FDatumColl.Add(DatumStr(SBuff));   // Str 2
                 end;
              2: begin
                   ReadStr(SBuff);
                   FAbschnNameCollArr[wkAbs1].Add(SBuff);  // Str 3
                 end;
              3: begin
                   ReadStr(SBuff);
                   FAbschnNameCollArr[wkAbs2].Add(SBuff);  // Str 4
                 end;
              4: begin
                   ReadStr(SBuff);
                   FAbschnNameCollArr[wkAbs3].Add(SBuff);  // Str 5
                 end;
              5: begin
                   ReadStr(SBuff);
                   FTlnTxtColl.Add(SBuff);  // Str 6
                 end;
              6: begin
                   // neu 2005
                   ReadStr(SBuff);
                   FSondTitelColl.Add(SBuff);  // Str 7
                 end;
              7: begin
                   // neu 2005-1.1
                   ReadStr(SBuff);
                   FAbschnNameCollArr[wkAbs4].Add(SBuff);    // Str 8
                 end;
              8,9,10,11: // ab 2009                          // Str 9..11
                 begin
                   ReadStr(SBuff);
                   AbsCnt := TWkAbschnitt(j-3); // 5..8
                   FAbschnNameCollArr[AbsCnt].Add(SBuff);
                 end;
              else ReadStr(SBuff);  // zukünftige Erweiterungen
            end
          else ReadStr(SBuff);  // zukünftige Erweiterungen

        // read SmallInt pro Ort in Coll
        ReadBuffer(C,cnSizeOfSmallInt);
        for j:=0 to C-1 do
          if i < TVeranstObj(FVPtr).OrtZahl then
            case j of
              0: begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 1
                   FWettkArtColl.Add(Buff);
                 end;
              1: begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 2
                   FMannschGrAnmColl.Add(Buff);
                 end;
              2: begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 3
                   FMannschGrStrtColl.Add(Buff);
                 end;
              3: begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 4
                   FMschGrAlleColl.Add(Buff);
                   if (TriDatei.Version.Jahr<'2011')or
                      (TriDatei.Version.Jahr='2011')and(TriDatei.Version.Nr<'2.4') then
                   begin
                     FMschGrMaennerColl.Add(Buff);
                     FMschGrFrauenColl.Add(Buff);
                     FMschGrMixedColl.Add(Buff);
                   end;
                 end;
              4: begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 5
                   FSchwimmDistanzColl.Add(Buff);
                 end;
              5: begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 6
                   FStartBahnenColl.Add(Buff);
                 end;
              6: begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 7
                   FAbschnZahlColl.Add(Buff);
                 end;
              7,8,9,10,11,12,13,14:                        // Int 8..15
                 begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);
                   AbsCnt := TWkAbschnitt(j-6); // 1..8
                   FAbschnRundCollArr[AbsCnt].Add(Buff);
                 end;
              15:begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 16
                   FMschWrtgModeColl.Add(Buff);
                 end;
              16:begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 17
                   FMschGrMaennerColl.Add(Buff);
                 end;
              17:begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 18
                   FMschGrFrauenColl.Add(Buff);
                 end;
              18:begin
                   ReadBuffer(Buff,cnSizeOfSmallInt);      // Int 19
                   FMschGrMixedColl.Add(Buff);
                 end;
              else ReadBuffer(Buff,cnSizeOfSmallInt);      // Zukunft
            end
          else ReadBuffer(Buff,cnSizeOfSmallInt);  // zukünftige Erweiterungen

        // read LongInt pro Ort in Coll
        ReadBuffer(C,cnSizeOfSmallInt);
        for j:=0 to C-1 do ReadBuffer(LBuff,cnSizeOfLongInt);      // zukunft

      end;

      // neu 2005
      if TriDatei.Version.Jahr<'2005' then
        for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do FSondTitelColl.Add('');
      if (TriDatei.Version.Jahr<'2005')or
         (TriDatei.Version.Jahr='2005')and(TriDatei.Version.Nr<'1.1') then
        for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do FAbschnNameCollArr[wkAbs4].Add('Ski');

      // neu 2007
      if TriDatei.Version.Jahr<'2007' then
        if EinlVeranst.Art <> vaLiga then
          for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do
          begin
            FMannschGrAnmColl[i]  := 0;
            FMannschGrStrtColl[i] := 0;
          end;

      // neu 2008-2.0
      if (TriDatei.Version.Jahr<'2008')or
         (TriDatei.Version.Jahr='2008')and(TriDatei.Version.Nr<'2.0') then
        for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do
          for AbsCnt:=wkAbs1 to wkAbs4 do
            FAbschnRundCollArr[AbsCnt].Add(1);

      // ab 2007 bis 2008-2.0 CupWrtgPktColl in VeranObj laden,
      // ab 2008-2.0 in WettkObj
      if (TriDatei.Version.Jahr>'2008')or
         (TriDatei.Version.Jahr='2008')and(TriDatei.Version.Nr>='2.0') then
      begin
        FTlnCupWrtgPktColl.Clear;
        if not FTlnCupWrtgPktColl.Load then Exit;
        FMschCupWrtgPktColl.Clear;
        if not FMschCupWrtgPktColl.Load then Exit;
      end;

      // neu 2009
      if TriDatei.Version.Jahr<'2009' then
        for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do
          for AbsCnt:=wkAbs5 to wkAbs8 do
          begin
            FAbschnNameCollArr[AbsCnt].Add('Run');
            FAbschnRundCollArr[AbsCnt].Add(1);
          end;

      // neu 2011
      if (TriDatei.Version.Jahr<'2010')or
         (TriDatei.Version.Jahr='2010')and(TriDatei.Version.Nr<'2.1') then
        for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do
          FMschWrtgModeColl.Add(Integer(wmTlnZeit));

    end

    else // altes Dateiformat vor 2004-1.1
    begin
      ReadStr(FName);
      // AkMin,AkMax ab 2004-1.1 nicht mehr benutzt
      ReadBuffer(AkMinBuff, cnSizeOfSmallInt); //Dummy
      ReadBuffer(AkMaxBuff, cnSizeOfSmallInt); //Dummy
      ReadStr(SBuff); // Dummy für FLigaKuerzel ab 2010
      ReadBuffer(WordBuf, cnSizeOfWord);
      FStreichErg[tmTln]  := WordBuf;
      ReadBuffer(WordBuf, cnSizeOfWord); // Dummy
      ReadBuffer(MschWrtgBuf, cnSizeOfWord);
      case MschWrtgBuf of
        0: FMschWertg := mwKein;
        1: FMschWertg := mwEinzel;
        2: FMschWertg := mwMulti;
      end;
      ReadBuffer(AkWrtgBuf, cnSizeOfWord); // Dummy, FMschGesWertg
      ReadBuffer(AkWrtgBuf, cnSizeOfWord); // Dummy, FTlnGesWertg
      if not FStandTitelColl.Load then Exit;
      if not FDatumColl.Load then Exit;
      // ab 2004-1.1 werden KlasseColl gespeichert
      // AkColl neu erstellen, nachdem Datum eingelesen wurde
      TlnAltMKlasseColl.Free;
      TlnSondMKlasseColl.Free;
      MschAltMKlasseColl.Free;
      TlnAltWKlasseColl.Free;
      TlnSondWKlasseColl.Free;
      MschAltWKlasseColl.Free;
      TlnAltMKlasseColl  := TAkColl.Create(FVPtr,GetOrtJahr(0),kwAltKl,cnMaennlich);
      TlnSondMKlasseColl := TAkColl.Create(FVPtr,GetOrtJahr(0),kwSondKl,cnMaennlich);
      MschAltMKlasseColl := TAkColl.Create(FVPtr,GetOrtJahr(0),kwAltKl,cnMaennlich);
      TlnAltWKlasseColl  := TAkColl.Create(FVPtr,GetOrtJahr(0),kwAltKl,cnWeiblich);
      TlnSondWKlasseColl := TAkColl.Create(FVPtr,GetOrtJahr(0),kwSondKl,cnWeiblich);
      MschAltWKlasseColl := TAkColl.Create(FVPtr,GetOrtJahr(0),kwAltKl,cnWeiblich);
      // Coll initialisieren
      TlnAltMKlasseColl.SetzeAkLimits(AkMinBuff,AkMaxBuff);
      TlnAltWKlasseColl.SetzeAkLimits(AkMinBuff,AkMaxBuff);
      MschAltMKlasseColl.SetzeAkLimits(AkMinBuff,AkMaxBuff);
      MschAltWKlasseColl.SetzeAkLimits(AkMinBuff,AkMaxBuff);

      if not FWettkArtColl.Load then Exit;
      if not FMannschGrAnmColl.Load then Exit;
      if not FMannschGrStrtColl.Load then Exit;
      if not FMschGrAlleColl.Load then Exit;
      if not FSchwimmDistanzColl.Load then Exit;
      if not FStartBahnenColl.Load then Exit;

      if not FAbschnZahlColl.Load then Exit;
      if not FAbschnNameCollArr[wkAbs1].Load then Exit;
      if not FAbschnNameCollArr[wkAbs2].Load then Exit;
      if not FAbschnNameCollArr[wkAbs3].Load then Exit;

      // ab 2003-1.4: Korrektur für ältere Versionen:
      // bei Einzelveranstaltung immer StandTitel = Name
      if (TriDatei.Version.Jahr<'2004') and not TVeranstObj(FVPtr).Serie then
        for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do FStandTitelColl[i] := Name;

      for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do
      begin
        FTlnTxtColl.Add('Land');
        FSondTitelColl.Add('');
        FAbschnNameCollArr[wkAbs4].Add('Ski');
        for AbsCnt:=wkAbs5 to wkAbs8 do
          FAbschnNameCollArr[AbsCnt].Add('Abs.'+IntToStr(Integer(AbsCnt)));
        for AbsCnt:=wkAbs1 to wkAbs8 do
          FAbschnRundCollArr[AbsCnt].Add(1);
        if EinlVeranst.Art <> vaLiga then
        begin
          FMannschGrAnmColl[i]  := 0;
          FMannschGrStrtColl[i] := 0;
        end;
        FMschWrtgModeColl.Add(Integer(wmTlnZeit));
        FMschGrMaennerColl.Add(FMschGrAlleColl[i]);
        FMschGrFrauenColl.Add(FMschGrAlleColl[i]);
        FMschGrMixedColl.Add(FMschGrAlleColl[i]);
      end;
    end;

    // einheitliche Anzeige für 'Alle Wettkämpfe' ab 2010 nicht mehr benutzt
    //if Self = WettkAlleDummy then FName := cnWettkAlleName;
    for i:=0 to TVeranstObj(FVPtr).OrtZahl-1 do
    begin
      FErgModifiedColl.Add(false);
      TlnImZielColl.Add(false);
      RngBuffColl.Add(0);
      FRngMaxTlnAlleColl.Add(0);
      FRngMaxTlnMaennerColl.Add(0);
      FRngMaxTlnFrauenColl.Add(0);
      FRngMaxMschAlleColl.Add(0);
      FRngMaxMschMaennerColl.Add(0);
      FRngMaxMschFrauenColl.Add(0);
      FRngMaxMschMixedColl.Add(0);

      FRngMaxTlnAkMColl.RngCollAdd(TlnAltMKlasseColl);
      FRngMaxTlnSkMColl.RngCollAdd(TlnSondMKlasseColl);
      FRngMaxMschAkMColl.RngCollAdd(MschAltMKlasseColl);
      FRngMaxTlnAkWColl.RngCollAdd(TlnAltWKlasseColl);
      FRngMaxTlnSkWColl.RngCollAdd(TlnSondWKlasseColl);
      FRngMaxMschAkWColl.RngCollAdd(MschAltWKlasseColl);
    end;

    // neu 2010
    // Seriewertungsoptionen komplett getrennt für Tln und Msch,
    // StreichOrt neu (Ortzahl - PflichtWettk)
    // bei Liga alle Daten pro Wettk aus WettkAlleDummy in WettkColl.Load übernehmen
    if TriDatei.Version.Jahr < '2010' then
      if TVeranstObj(FVPtr).Art=vaLiga then
      begin
        FStreichErg[tmMsch]     := 0;
        FPflichtWkMode[tmMsch]  := pw0;
        FPflichtWkOrt1[tmMsch]  := nil;
        FPflichtWkOrt2[tmMsch]  := nil;
        FPunktGleichOrt[tmMsch] := FPunktGleichOrt[tmTln];
        FStreichOrt[tmTln]      := 0;
        FStreichOrt[tmMsch]     := TVeranstObj(FVPtr).OrtZahl;
      end else
      begin
        FStreichErg[tmMsch]     := FStreichErg[tmTln];
        FPflichtWkMode[tmMsch]  := FPflichtWkMode[tmTln];
        FPflichtWkOrt1[tmMsch]  := FPflichtWkOrt1[tmTln];
        FPflichtWkOrt2[tmMsch]  := FPflichtWkOrt2[tmTln];
        FPunktGleichOrt[tmMsch] := FPunktGleichOrt[tmTln];
        FStreichOrt[tmTln]      := FStreichErg[tmTln];
        FStreichOrt[tmMsch]     := FStreichOrt[tmTln];
      end;

    //neu 2011-2
    if (TriDatei.Version.Jahr<'2011')or
       (TriDatei.Version.Jahr='2011')and(TriDatei.Version.Nr<'1.4') then
      SetSerWrtgJahr(GetOrtJahr(0));

  except
    Result := false;
    Exit;
  end;

  Result := true;
  {if MemAvail<cnLowMemSize then S.Error(stLowMemError,0);}
end;

(*============================================================================*)
function TWettkObj.Store;
(*============================================================================*)
var i : Integer;
    Buff,C,Orte: SmallInt;
    AbsCnt : TWkAbschnitt;
begin
  Result := false;
  if not inherited Store then Exit; // BPObjType
  with TriaStream do
  try
    // store allg Strings in Coll
    C := 6;
    WriteBuffer(C,cnSizeOfSmallInt);
    WriteStr(FName);                  // Str 1
    WriteStr('');                     // Str 2, Dummy für FLigaKuerzel ab 2010
    WriteStr(FTlnMKlasse.Name);       // Str 3 2005
    WriteStr(FTlnWKlasse.Name);       // Str 4
    WriteStr(FMschMKlasse.Name);      // Str 5
    WriteStr(FMschWKlasse.Name);      // Str 6
    // store allg SmallInt in Coll
    C := 18;
    WriteBuffer(C,cnSizeOfSmallInt);
    {case GetTlnGesWertg of
      gwAlleAk:   Buff := 0;
      gwMannFrau: Buff := 1;
      gwProAk:    Buff := 2;
    end;}
    Buff := 0; // TlnGesWertg
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 1
    case GetMschWertg of
      mwKein:   Buff := 0;
      mwEinzel: Buff := 1;
      mwMulti:  Buff := 2;
    end;
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 2
    {case GetMschGesWertg of
      gwAlleAk:   Buff := 0;
      gwMannFrau: Buff := 1;
      gwProAk:    Buff := 2;
    end;}
    Buff := 0; // MschGesWertg
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 3

    Buff := FStreichErg[tmTln];
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 4
    Buff := GetPunktGleichOrtIndx(tmTln);
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 5
    Buff := Integer(GetPflichtWkMode(tmTln));
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 6
    Buff := GetPflichtWkOrt1Indx(tmTln);
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 7
    Buff := GetPflichtWkOrt2Indx(tmTln);
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 8
    Buff := FStreichOrt[tmTln];
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 9

    Buff := FStreichErg[tmMsch];
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 10
    Buff := GetPunktGleichOrtIndx(tmMsch);
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 11
    Buff := Integer(GetPflichtWkMode(tmMsch));
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 12
    Buff := GetPflichtWkOrt1Indx(tmMsch);
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 13
    Buff := GetPflichtWkOrt2Indx(tmMsch);
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 14
    Buff := FStreichOrt[tmMsch];
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 15
    Buff := FSerWrtgJahr;
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 16 - ab 11.1.4
    case FTlnSerPktMode of
      spFlexPkt    : Buff := 0;
      spRngUpPkt   : Buff := 1;
      spRngDownPkt : Buff := 2;
    end;
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 17 - ab 11.2.4
    case FMschSerPktMode of
      spFlexPkt    : Buff := 0;
      spRngUpPkt   : Buff := 1;
      spRngDownPkt : Buff := 2;
    end;
    WriteBuffer(Buff,cnSizeOfSmallInt);     // Int 18 - ab 11.2.4

    // store allg LongInt in Coll
    C := 0;
    WriteBuffer(C,cnSizeOfSmallInt);

    // store 6x KlasseColl
    C := 6;
    WriteBuffer(C,cnSizeOfSmallInt);
    if not TlnAltMKlasseColl.Store then Exit;
    if not TlnSondMKlasseColl.Store then Exit;
    if not MschAltMKlasseColl.Store then Exit;
    if not TlnAltWKlasseColl.Store then Exit;
    if not TlnSondWKlasseColl.Store then Exit;
    if not MschAltWKlasseColl.Store then Exit;

    // store Ort Collections, momentan nur pro Ort
    Orte := TVeranstObj(FVPtr).OrtZahl;
    WriteBuffer(Orte,cnSizeOfSmallInt);
    for i:=0 to Orte-1 do
    begin
      // store Strings pro Ort in Coll
      C := 12; // momentan für alle Orte gleich
      WriteBuffer(C,cnSizeOfSmallInt);
      WriteStr(FStandTitelColl[i]);             // Str 1
      WriteStr(FDatumColl[i]);                  // Str 2
      WriteStr(FAbschnNameCollArr[wkAbs1][i]);  // Str 3
      WriteStr(FAbschnNameCollArr[wkAbs2][i]);  // Str 4
      WriteStr(FAbschnNameCollArr[wkAbs3][i]);  // Str 5
      WriteStr(FTlnTxtColl[i]);                 // Str 6
      WriteStr(FSondTitelColl[i]);              // Str 7
      for AbsCnt:=wkAbs4 to wkAbs8 do
        WriteStr(FAbschnNameCollArr[AbsCnt][i]);// Str 8..12
      // store SmallInt pro Ort in Coll
      C := 19;
      WriteBuffer(C,cnSizeOfSmallInt);
      Buff := FWettkArtColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 1
      Buff := FMannschGrAnmColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 2
      Buff := FMannschGrStrtColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 3
      Buff := FMschGrAlleColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 4
      Buff := FSchwimmDistanzColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 5
      Buff := FStartBahnenColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 6
      Buff := FAbschnZahlColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 7
      for AbsCnt:=wkAbs1 to wkAbs8 do
      begin
        Buff := FAbschnRundCollArr[AbsCnt][i];
        WriteBuffer(Buff,cnSizeOfSmallInt); // Int 8..15
      end;
      Buff := FMschWrtgModeColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 16
      Buff := FMschGrMaennerColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 17
      Buff := FMschGrFrauenColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 18
      Buff := FMschGrMixedColl[i];
      WriteBuffer(Buff,cnSizeOfSmallInt);   // Int 19

      // store allg LongInt in Coll
      C := 0;
      WriteBuffer(C,cnSizeOfSmallInt);

    end;

    // ab 2007 bis 2008-2.0 Store in VeranObj.Store:
    if not FTlnCupWrtgPktColl.Store then Exit;
    if not FMschCupWrtgPktColl.Store then Exit;

  except
    Result := false;
    Exit;
  end;
  Result := true;
end;

(*============================================================================*)
procedure TWettkObj.OrtCollAdd;
(*============================================================================*)
var S : String;
    AbsCnt : TWkabschnitt;
begin
  FStandTitelColl.Add(FName);
  (* für nachf. Wettk. Datum von Wettk.0 übernehmen, sonst aktuelles datum *)
  if (FCollection <> nil) and (FCollection.Count > 0) and (GetIndex > 0)
    then S := TWettkObj(FCollection[0]).FDatumColl[FDatumColl.Count]
    else S := SystemDatum;
  FDatumColl.Add(DatumStr(S));
  FWettkArtColl.Add(0);
  FMschWrtgModeColl.Add(0);
  FMannschGrAnmColl.Add(0);
  FMannschGrStrtColl.Add(0);
  FMschGrAlleColl.Add(cnMschGrDefault);
  FMschGrMaennerColl.Add(cnMschGrDefault);
  FMschGrFrauenColl.Add(cnMschGrDefault);
  FMschGrMixedColl.Add(cnMschGrDefault);
  FSchwimmDistanzColl.Add(0);
  FStartBahnenColl.Add(0);
  FErgModifiedColl.Add(false);
  FAbschnZahlColl.Add(3);
  FAbschnNameCollArr[wkAbs1].Add('Swim');
  FAbschnNameCollArr[wkAbs2].Add('Bike');
  FAbschnNameCollArr[wkAbs3].Add('Run');
  FAbschnNameCollArr[wkAbs4].Add('Ski');
  for AbsCnt:=wkAbs5 to wkAbs8 do
    FAbschnNameCollArr[AbsCnt].Add('Abs.'+IntToStr(Integer(AbsCnt)));
  for AbsCnt:=wkAbs1 to wkAbs8 do
    FAbschnRundCollArr[AbsCnt].Add(1);
  FTlnTxtColl.Add('Land');
  TlnImZielColl.Add(false);
  RngBuffColl.Add(0);
  FSondTitelColl.Add('');
  FRngMaxTlnAlleColl.Add(0);
  FRngMaxTlnMaennerColl.Add(0);
  FRngMaxTlnFrauenColl.Add(0);
  FRngMaxMschAlleColl.Add(0);
  FRngMaxMschMaennerColl.Add(0);
  FRngMaxMschFrauenColl.Add(0);
  FRngMaxMschMixedColl.Add(0);
  FRngMaxTlnAkMColl.Add(0);
  FRngMaxTlnSkMColl.Add(0);
  FRngMaxMschAkMColl.Add(0);
  FRngMaxTlnAkWColl.Add(0);
  FRngMaxTlnSkWColl.Add(0);
  FRngMaxMschAkWColl.Add(0);
end;

(*============================================================================*)
procedure TWettkObj.OrtCollClear(Indx:Integer);
(*============================================================================*)
var AbsCnt : TWkabschnitt;
begin
  if (Indx<0) or (Indx>FStandTitelColl.Count-1) then Exit;
  FStandTitelColl.ClearIndex(Indx);
  FDatumColl.ClearIndex(Indx);
  FWettkArtColl.ClearIndex(Indx);
  FMschWrtgModeColl.ClearIndex(Indx);
  FMannschGrAnmColl.ClearIndex(Indx);
  FMannschGrStrtColl.ClearIndex(Indx);
  FMschGrAlleColl.ClearIndex(Indx);
  FMschGrMaennerColl.ClearIndex(Indx);
  FMschGrFrauenColl.ClearIndex(Indx);
  FMschGrMixedColl.ClearIndex(Indx);
  FSchwimmDistanzColl.ClearIndex(Indx);
  FStartBahnenColl.ClearIndex(Indx);
  FErgModifiedColl.ClearIndex(Indx);
  FAbschnZahlColl.ClearIndex(Indx);
  for AbsCnt:=wkAbs1 to wkAbs8 do
  begin
    FAbschnNameCollArr[AbsCnt].ClearIndex(Indx);
    FAbschnRundCollArr[AbsCnt].ClearIndex(Indx);
  end;
  FTlnTxtColl.ClearIndex(Indx);
  TlnImZielColl.ClearIndex(Indx);
  RngBuffColl.ClearIndex(Indx);
  FSondTitelColl.ClearIndex(Indx);
  FRngMaxTlnAlleColl.ClearIndex(Indx);
  FRngMaxTlnMaennerColl.ClearIndex(Indx);
  FRngMaxTlnFrauenColl.ClearIndex(Indx);
  FRngMaxMschAlleColl.ClearIndex(Indx);
  FRngMaxMschMaennerColl.ClearIndex(Indx);
  FRngMaxMschFrauenColl.ClearIndex(Indx);
  FRngMaxMschMixedColl.ClearIndex(Indx);
  FRngMaxTlnAkMColl.ClearIndex(Indx);
  FRngMaxTlnSkMColl.ClearIndex(Indx);
  FRngMaxMschAkMColl.ClearIndex(Indx);
  FRngMaxTlnAkWColl.ClearIndex(Indx);
  FRngMaxTlnSkWColl.ClearIndex(Indx);
  FRngMaxMschAkWColl.ClearIndex(Indx);
end;

(*============================================================================*)
procedure TWettkObj.OrtCollExch(Idx1,Idx2:Integer);
(*============================================================================*)
var AbsCnt : TWkabschnitt;
begin
  FStandTitelColl.List.Exchange(Idx1,Idx2);
  FDatumColl.List.Exchange(Idx1,Idx2);
  FWettkArtColl.List.Exchange(Idx1,Idx2);
  FMschWrtgModeColl.List.Exchange(Idx1,Idx2);
  FMannschGrAnmColl.List.Exchange(Idx1,Idx2);
  FMannschGrStrtColl.List.Exchange(Idx1,Idx2);
  FMschGrAlleColl.List.Exchange(Idx1,Idx2);
  FMschGrMaennerColl.List.Exchange(Idx1,Idx2);
  FMschGrFrauenColl.List.Exchange(Idx1,Idx2);
  FMschGrMixedColl.List.Exchange(Idx1,Idx2);
  FSchwimmDistanzColl.List.Exchange(Idx1,Idx2);
  FStartBahnenColl.List.Exchange(Idx1,Idx2);
  FErgModifiedColl.List.Exchange(Idx1,Idx2);
  FAbschnZahlColl.List.Exchange(Idx1,Idx2);
  for AbsCnt:=wkAbs1 to wkAbs8 do
  begin
    FAbschnNameCollArr[AbsCnt].List.Exchange(Idx1,Idx2);
    FAbschnRundCollArr[AbsCnt].List.Exchange(Idx1,Idx2);
  end;
  FTlnTxtColl.List.Exchange(Idx1,Idx2);
  TlnImZielColl.List.Exchange(Idx1,Idx2);
  RngBuffColl.List.Exchange(Idx1,Idx2);
  FSondTitelColl.List.Exchange(Idx1,Idx2);
  FRngMaxTlnAlleColl.List.Exchange(Idx1,Idx2);
  FRngMaxTlnMaennerColl.List.Exchange(Idx1,Idx2);
  FRngMaxTlnFrauenColl.List.Exchange(Idx1,Idx2);
  FRngMaxMschAlleColl.List.Exchange(Idx1,Idx2);
  FRngMaxMschMaennerColl.List.Exchange(Idx1,Idx2);
  FRngMaxMschFrauenColl.List.Exchange(Idx1,Idx2);
  FRngMaxMschMixedColl.List.Exchange(Idx1,Idx2);
  FRngMaxTlnAkMColl.List.Exchange(Idx1,Idx2);
  FRngMaxTlnSkMColl.List.Exchange(Idx1,Idx2);
  FRngMaxMschAkMColl.List.Exchange(Idx1,Idx2);
  FRngMaxTlnAkWColl.List.Exchange(Idx1,Idx2);
  FRngMaxTlnSkWColl.List.Exchange(Idx1,Idx2);
  FRngMaxMschAkWColl.List.Exchange(Idx1,Idx2);
end;


(*============================================================================*)
procedure TWettkObj.SetWettkAllgDaten(Name: String;
                                      StreichErgTlnNeu,StreichErgMschNeu:Integer;
                                      StreichOrtTlnNeu,StreichOrtMschNeu: Integer;
                                      PflichtWkModeTlnNeu,PflichtWkModeMschNeu: TPflichtWkMode;
                                      PflichtWkOrt1TlnNeu,PflichtWkOrt1MschNeu,
                                      PflichtWkOrt2TlnNeu,PflichtWkOrt2MschNeu: TOrtObj;
                                      PunktGleichOrtTlnNeu,PunktGleichOrtMschNeu:TOrtObj;
                                      MschWertgNeu:TMschWertung;
                                      SerWrtgJahrNeu:Integer;
                                      TlnSerPktModeNeu,MschSerPktModeNeu:TSerPktMode);
(*============================================================================*)
begin
  SetName(Name);
  SetMschWertg(MschWertgNeu);
  SetStreichErg(tmTln,StreichErgTlnNeu);
  SetStreichErg(tmMsch,StreichErgMschNeu);
  SetStreichOrt(tmTln,StreichOrtTlnNeu);
  SetStreichOrt(tmMsch,StreichOrtMschNeu);
  SetPflichtWkMode(tmTln,PflichtWkModeTlnNeu);
  SetPflichtWkMode(tmMsch,PflichtWkModeMschNeu);
  SetPflichtWkOrt1(tmTln,PflichtWkOrt1TlnNeu);
  SetPflichtWkOrt1(tmMsch,PflichtWkOrt1MschNeu);
  SetPflichtWkOrt2(tmTln,PflichtWkOrt2TlnNeu);
  SetPflichtWkOrt2(tmMsch,PflichtWkOrt2MschNeu);
  SetPunktGleichOrt(tmTln,PunktGleichOrtTlnNeu);
  SetPunktGleichOrt(tmMsch,PunktGleichOrtMschNeu);
  SetSerWrtgJahr(SerWrtgJahrNeu);
  FTlnSerPktMode := TlnSerPktModeNeu;
  FMschSerPktMode := MschSerPktModeNeu;
end;

(*============================================================================*)
procedure TWettkObj.SetWettkOrtDaten(StandTitelNeu,SondTitelNeu,DatumNeu:String;
                                     WettkArtNeu:TWettkArt;AbschnZahlNeu,
                                     Abs1RndNeu,Abs2RndNeu,Abs3RndNeu,Abs4RndNeu,
                                     Abs5RndNeu,Abs6RndNeu,Abs7RndNeu,Abs8RndNeu:Integer;
                                     Abs1NameNeu,Abs2NameNeu,Abs3NameNeu,Abs4NameNeu,
                                     Abs5NameNeu,Abs6NameNeu,Abs7NameNeu,Abs8NameNeu,
                                     TlnTxtNeu:String; MschWrtgModeNeu:TMschWrtgMode;
                                     MannschGrAnmNeu,MannschGrStrtNeu,MschGrAlleNeu,
                                     MschGrMaennerNeu,MschGrFrauenNeu,MschGrMixedNeu,
                                     SchwimmDistanzNeu,StartBahnenNeu:Integer);
(*============================================================================*)
begin
  if FVPtr<>nil then
  begin
    SetDatum(DatumNeu);
    SetWettkArt(WettkArtNeu);
    SetMschWrtgMode(MschWrtgModeNeu);
    SetAbschnZahl(AbschnZahlNeu);
    SetAbschnRunden(wkAbs1,Abs1RndNeu);
    SetAbschnRunden(wkAbs2,Abs2RndNeu);
    SetAbschnRunden(wkAbs3,Abs3RndNeu);
    SetAbschnRunden(wkAbs4,Abs4RndNeu);
    SetAbschnRunden(wkAbs5,Abs5RndNeu);
    SetAbschnRunden(wkAbs6,Abs6RndNeu);
    SetAbschnRunden(wkAbs7,Abs7RndNeu);
    SetAbschnRunden(wkAbs8,Abs8RndNeu);
    SetAbschnName(wkAbs1,Abs1NameNeu);
    SetAbschnName(wkAbs2,Abs2NameNeu);
    SetAbschnName(wkAbs3,Abs3NameNeu);
    SetAbschnName(wkAbs4,Abs4NameNeu);
    SetAbschnName(wkAbs5,Abs5NameNeu);
    SetAbschnName(wkAbs6,Abs6NameNeu);
    SetAbschnName(wkAbs7,Abs7NameNeu);
    SetAbschnName(wkAbs8,Abs8NameNeu);
    SetTlnTxt(TlnTxtNeu);
    FSchwimmDistanzColl[TVeranstObj(FVPtr).OrtIndex] := SchwimmDistanzNeu;
    FStartBahnenColl[TVeranstObj(FVPtr).OrtIndex]    := StartBahnenNeu;
    FStandTitelColl[TVeranstObj(FVPtr).OrtIndex]     := Trim(StandTitelNeu);
    FSondTitelColl[TVeranstObj(FVPtr).OrtIndex]      := Trim(SondTitelNeu);
    SetMannschGrAnm(MannschGrAnmNeu);
    SetMannschGrStrt(MannschGrStrtNeu);
    SetMschGroesse(cnSexBeide,MschGrAlleNeu);
    SetMschGroesse(cnMaennlich,MschGrMaennerNeu);
    SetMschGroesse(cnWeiblich,MschGrFrauenNeu);
    SetMschGroesse(cnMixed,MschGrMixedNeu);
  end;
end;

(*============================================================================*)
function TWettkObj.GetTlnAlter(Jg:Integer): Integer;
(*============================================================================*)
// bei Serienwertung Datum im aktuellen Ort, unabhängig vom SerWrtgJahr
// gleich für Tln- und MschWrtg
begin
  //Result := GetOrtJahr(0) - Jg; // bei Serie gilt Datum im 1. Ort
  if (FVPtr<>nil) and (TVeranstObj(FVPtr).Art = vaEinzel) then
    Result := GetJahr - Jg
  else
    Result := FSerWrtgJahr - Jg;
  if (Result > cnAlterMax) or (Result < cnAlterMin) then Result := 0;
end;

(*============================================================================*)
function TWettkObj.GetTlnKlasse(AkWrtg:TKlassenWertung;Sx:TSex;Jg:Integer):TAkObj;
(*============================================================================*)
var i, Alter : Integer;
    AkColl   : TAkColl;
begin
  case AkWrtg of
    kwAlle: Result := AkAlle; //unabhängig von Sex und Jg
    kwSex:  case Sx of
              cnMaennlich : Result := FTlnMKlasse;
              cnWeiblich  : Result := FTlnWKlasse;
              else          Result := AkUnbekannt;
            end;
    kwAltKl,kwSondKl:
    begin
      case Sx of
        cnMaennlich : Result := AkMannUnbek;
        cnWeiblich  : Result := AkFrauUnbek;
        else begin
          Result := AkUnbekannt; // Klassen nur pro Geschlecht
          Exit;
        end;
      end;
      if AkWrtg = kwAltKl then
        if Sx = cnMaennlich then AkColl := TlnAltMKlasseColl
                            else AkColl := TlnAltWKlasseColl
      else
        if Sx = cnMaennlich then AkColl := TlnSondMKlasseColl
                            else AkColl := TlnSondWKlasseColl;
      Alter := GetTlnAlter(Jg);
      if Alter > 0 then
        for i:=0 to AkColl.Count-1 do
          if (Alter>=AkColl[i].AlterVon) and (Alter<=AkColl[i].AlterBis) then
          begin
            Result := AkColl[i];
            Exit;
          end;
    end;
    else Result := AkUnbekannt;
  end;
end;

(*============================================================================*)
function TWettkObj.GetMschKlasse(AkWrtg:TKlassenWertung;Sx:TSex;Jg:Integer):TAkObj;
(*============================================================================*)
var i, Alter : Integer;
    AkColl   : TAkColl;
begin
  case AkWrtg of
    kwAlle: Result := AkAlle; //unabhängig von Sex und Jg
    kwSex:  case Sx of
              cnMaennlich : Result := FMschMKlasse;
              cnWeiblich  : Result := FMschWKlasse;
              cnMixed     : Result := AkMixed;
              else          Result := AkUnbekannt;
            end;
    kwAltKl:
    begin
      case Sx of
        cnMaennlich : Result := AkMannUnbek;
        cnWeiblich  : Result := AkFrauUnbek;
        else begin
          Result := AkUnbekannt; // Klassen nur pro Geschlecht
          Exit;
        end;
      end;
      if Sx = cnMaennlich then AkColl := MschAltMKlasseColl
                          else AkColl := MschAltWKlasseColl;
      Alter := GetTlnAlter(Jg);
      if Alter > 0 then
        for i:=0 to AkColl.Count-1 do
          if (Alter>=AkColl[i].AlterVon) and (Alter<=AkColl[i].AlterBis) then
          begin
            Result := AkColl[i];
            Exit;
          end;
    end;
    else Result := AkUnbekannt; // keine SonderKlassen
  end;
end;

//==============================================================================
function TWettkObj.MschGroesseMin: Integer;
//==============================================================================
var Buf : Integer;
begin
  Result := GetMschGroesse(cnSexBeide);
  Buf := GetMschGroesse(cnMaennlich);
  if (Buf > 0) and (Buf < Result) then Result := Buf;
  Buf := GetMschGroesse(cnWeiblich);
  if (Buf > 0) and (Buf < Result) then Result := Buf;
  Buf := GetMschGroesse(cnMixed);
  if (Buf > 0) and (Buf < Result) then Result := Buf;
end;

//==============================================================================
function TWettkObj.MschGroesseMax: Integer;
//==============================================================================
begin
  Result := Max(GetMschGroesse(cnSexBeide),
                Max(GetMschGroesse(cnMaennlich),
                    Max(GetMschGroesse(cnWeiblich),GetMschGroesse(cnMixed))));
end;

(*============================================================================*)
procedure TWettkObj.KlasseCollKopieren(ZielColl,QuelColl:TAkColl);
(*============================================================================*)
var KlNeu, EinlKl : TAkObj;
    i : Integer;
begin
  ZielColl.Clear;
  for i:=0 to QuelColl.Count-1 do
  begin
    EinlKl := QuelColl[i];
    KlNeu:=TAkObj.Create(FVPtr,ZielColl,oaAdd);
    KlNeu.Init(EinlKl.Name,EinlKl.Kuerzel,EinlKl.AlterVon,EinlKl.AlterBis,EinlKl.Sex,EinlKl.Wertung);
    // setze EinlKl.LoadPtr als Pointer für Tln.Klasse
    EinlKl.LoadPtr := KlNeu;
    ZielColl.AddItem(KlNeu);
  end;
end;

(*============================================================================*)
procedure TWettkObj.KlassenKopieren(Wk:TWettkObj);
(*============================================================================*)
// in ImpFrm benutzt
var i : Integer;
begin
  if FVPtr=nil then Exit;
  for i:=0 to TVeranstObj(FVPtr).TlnColl.Count-1 do
    TVeranstObj(FVPtr).TlnColl[i].KlassenLoeschen;
  for i:=0 to TVeranstObj(FVPtr).MannschColl.Count-1 do
    TVeranstObj(FVPtr).MannschColl[i].Klasse := AkUnbekannt;
  KlasseCollKopieren(TlnAltMKlasseColl,Wk.TlnAltMKlasseColl);
  KlasseCollKopieren(TlnAltWKlasseColl,Wk.TlnAltWKlasseColl);
  KlasseCollKopieren(TlnSondMKlasseColl,Wk.TlnSondMKlasseColl);
  KlasseCollKopieren(TlnSondWKlasseColl,Wk.TlnSondWKlasseColl);
  KlasseCollKopieren(MschAltMKlasseColl,Wk.MschAltMKlasseColl);
  KlasseCollKopieren(MschAltWKlasseColl,Wk.MschAltWKlasseColl);
  SetKlassenModified(true);
end;

{(*============================================================================*)
procedure TWettkObj.CupWrtgCollKopieren(ZielColl,QuelColl:TCupWrtgPktColl);
(*============================================================================*)
var RecNeu : TCupWrtgPktRec;
    i : Integer;
begin
  if (ZielColl<>TlnCupWrtgPktColl) and (ZielColl<>TlnCupWrtgPktColl) then Exit;
  ZielColl.Clear;
  for i:=0 to QuelColl.Count-1 do
  begin
    with QuelColl[i]^ do
    begin
      RecNeu.RngVon  := RngVon;
      RecNeu.RngBis  := RngBis;
      RecNeu.PktVon  := PktVon;
      RecNeu.PktIncr := PktIncr;
    end;
    ZielColl.Add(RecNeu);
  end;
end; }

(*============================================================================*)
function TWettkObj.TlnOrtSerPkt(Indx:Integer;Klasse:TAkObj;Rng:Integer): Integer;
(*============================================================================*)
begin
  Result := 0;
  if (Indx<0) or (Indx>=TVeranstObj(FVPtr).OrtZahl) then Exit;

  case TlnSerPktMode of
    spRngUpPkt:
    begin
      // Rng=0 ==> 10,100,1000,10000 Pkt, abh. von angemeldete Tln, gleich für alle Orte
      // sonst ==> Pkt = Rng
      if Rng=0 then
      begin
        Result := Veranstaltung.TlnColl.OrtTlnZahl(Indx,Self,Klasse,stSerGemeldet);
        if Result > 999 then Result := 10000
        else if Result > 99 then Result := 1000
        else if Result > 9 then Result := 100
        else if Result > 0 then Result := 10;  // 0 Pkt wenn keine Tln
      end else
        Result := Rng;
    end;
    spRngDownPkt:
    begin
      // Rng=0 ==> 0 Pkt
      // sonst ==> Pkt = MaxRng - Rng + 1
      if Rng > 0 then
      begin
        // MaxRng pro Klasse
        case Klasse.Wertung of
          kwAlle: Result := FRngMaxTlnAlleColl[Indx];
          kwSex :
            if Klasse.Sex = cnWeiblich then
              Result := FRngMaxTlnFrauenColl[Indx]
            else
              Result := FRngMaxTlnMaennerColl[Indx];
          kwAltKl:
            if (Klasse.Sex = cnWeiblich) and (TlnAltWKlasseColl.IndexOf(Klasse) >= 0) then
              Result := FRngMaxTlnAkWColl[Indx][TlnAltWKlasseColl.IndexOf(Klasse)]
            else
            if (Klasse.Sex = cnMaennlich) and (TlnAltMKlasseColl.IndexOf(Klasse) >= 0) then
              Result := FRngMaxTlnAkMColl[Indx][TlnAltMKlasseColl.IndexOf(Klasse)];
          kwSondKl:
            if (Klasse.Sex = cnWeiblich) and (TlnSondWKlasseColl.IndexOf(Klasse) >= 0) then
              Result := FRngMaxTlnSkWColl[Indx][TlnSondWKlasseColl.IndexOf(Klasse)]
            else
            if (Klasse.Sex = cnMaennlich) and (TlnSondMKlasseColl.IndexOf(Klasse) >= 0) then
              Result := FRngMaxTlnSkMColl[Indx][TlnSondMKlasseColl.IndexOf(Klasse)];
        end;
        Result := Max(0, Result - Rng + 1);
      end;
    end;
    else // spFlexPkt
      Result := FTlnCupWrtgPktColl.GetCupPkt(Rng);
  end;
end;

(*============================================================================*)
function TWettkObj.MschOrtSerPkt(Indx:Integer;Klasse:TAkObj;Rng:Integer): Integer;
(*============================================================================*)
begin
  Result := 0;
  if (Indx<0) or (Indx>=TVeranstObj(FVPtr).OrtZahl) then Exit;

  case MschSerPktMode of
    spRngUpPkt:
    begin
      // Rng=0 ==> 10,100,1000,10000 Pkt, abh. von angemeldete Msch, gleich für alle Orte
      // sonst ==> Pkt = Rng
      if Rng=0 then
      begin
        Result := Veranstaltung.MannschColl.OrtMschAnzahl(Indx,Self,Klasse,stGemeldet);
        if Result > 999 then Result := 10000
        else if Result > 99 then Result := 1000
        else if Result > 9 then Result := 100
        else if Result > 0 then Result := 10; // 0 Pkt wenn keine Msch
      end else
        Result := Rng;
    end;
    spRngDownPkt:
    begin
      // Rng=0 ==> 0 Pkt
      // sonst ==> Pkt = MaxRng - Rng + 1
      if Rng > 0 then
      begin
        // MaxRng pro Klasse
        case Klasse.Wertung of
          kwAlle: Result := FRngMaxMschAlleColl[Indx];
          kwSex :
            if Klasse.Sex = cnWeiblich then
              Result := FRngMaxMschFrauenColl[Indx]
            else
            if Klasse.Sex = cnMixed then
              Result := FRngMaxMschMixedColl[Indx]
            else
              Result := FRngMaxMschMaennerColl[Indx];
          kwAltKl:
            if (Klasse.Sex = cnWeiblich) and (MschAltWKlasseColl.IndexOf(Klasse) >= 0) then
              Result := FRngMaxMschAkWColl[Indx][MschAltWKlasseColl.IndexOf(Klasse)]
            else
            if (Klasse.Sex = cnMaennlich) and (MschAltMKlasseColl.IndexOf(Klasse) >= 0) then
              Result := FRngMaxMschAkMColl[Indx][MschAltMKlasseColl.IndexOf(Klasse)];
        end;
        Result := Max(0, Result - Rng + 1);
      end;
    end;
    else // spFlexPkt
      Result := FMschCupWrtgPktColl.GetCupPkt(Rng);
  end;
end;

(*============================================================================*)
function TWettkObj.TlnCupPktIncr: Boolean;
(*============================================================================*)
begin
  Result := FTlnCupWrtgPktColl.CupPktIncr;
end;

(*============================================================================*)
function TWettkObj.MschCupPktIncr: Boolean;
(*============================================================================*)
begin
  Result := FMschCupWrtgPktColl.CupPktIncr;
end;

(*============================================================================*)
function TWettkObj.EinzelWettk: Boolean;
(*============================================================================*)
begin
  Result := (WettkArt=waEinzel)or(WettkArt=waTlnStaffel)or(WettkArt=waRndRennen);
end;

//==============================================================================
function TWettkObj.EinzelStart: Boolean;
//==============================================================================
// pro Wettkampf
var i : Integer;
begin
  Result := false;
  if Self=WettkAlleDummy then Exit;
  with TVeranstObj(FVPtr).SGrpColl do
    for i:=0 to Count-1 do
      if Self=Items[i].Wettkampf then
      begin
        Result := Items[i].StartModus[wkAbs1] = stOhnePause; // Einzelstart
        Exit;
      end;

end;

(*============================================================================*)
function TWettkObj.MschWettk: Boolean;
(*============================================================================*)
begin
  Result := (WettkArt<>waEinzel)and(WettkArt<>waTlnStaffel)and(WettkArt<>waRndRennen);
end;

(*============================================================================*)
function TWettkObj.TlnOrtSerWertung(Indx:Integer): Boolean;
(*============================================================================*)
// Staffel- und Teamwettbewerbe werden bei Tln-SerWertung nicht berücksichtigt
begin
  if (FVPtr<>nil) and (FCollection<>nil) and
     (Indx>=0) and (Indx<TVeranstObj(FVPtr).OrtZahl) then
    Result := (GetOrtWettkArt(Indx) = waEinzel) or
              (GetOrtWettkArt(Indx) = waRndRennen)
  else Result := false;
end;

(*============================================================================*)
function TWettkObj.SexSortMode: TSortMode;
(*============================================================================*)
begin
  Result := smSxBeide; //nur Wertung über alle Tln (kwAlle)
  if (FVPtr=nil) or (FCollection=nil) then Exit;

  case HauptFenster.Ansicht of
    anAnmEinzel,
    anAnmSammel,
    anTlnStart,
    anTlnErg,
    anTlnErgSerie:  Result := smSxBeideMF; // Beide, Männer, Frauen

    anMschStart,     // nie WettkAlleDummy
    anMschErgDetail,
    anMschErgKompakt,
    anMschErgSerie:
      if (TVeranstObj(FVPtr).Art<>vaLiga) and EinzelWettk then
        Result := smSxBeideMF // Beide, Männer, Frauen
      else Result := smSxBeide; //MschWertung nur über alle Tln (kwAlle)

    anTlnUhrZeit,
    anTlnRndKntrl,
    anTlnSchwDist:  Result := smSxBeide; //nur Beide
  end;
end;

(*============================================================================*)
function TWettkObj.JgLang(J:String): Integer;
(*============================================================================*)
// J='0' wird als 2000 gewertet, J='' als 0
// 2-stellig in 4-stellig gewandelt
begin
  Result := StrToIntDef(Trim(J),0);
  if (Length(Trim(J)) = 1) or (Length(Trim(J)) = 2) then
  begin
    // hochrechnen auf 1900/2000, WettkJahr: 2000-2099, Alter 1-99
    Result := Result + (GetJahr DIV 100) * 100;
    if  Result > Jahr then Result := Result - 100;
  end;
end;

//==============================================================================
function TWettkObj.LangeAkKuerzel: Boolean;
//==============================================================================
// für alle Ak prüfen ob Kürzel länger als 3 vorhanden sind
//------------------------------------------------------------------------------
var i : Integer;
function LangeKuerzel(AkColl: TAkColl): Boolean;
var i: Integer;
begin
  Result := false;
  for i:=0 to AkColl.Count-1 do
    if Length(AkColl[i].Kuerzel) > 3  then
    begin
      Result := true;
      Exit;
    end;
end;
//------------------------------------------------------------------------------
function LangeKuerzelWk(Wk:TWettkObj): Boolean;
begin
  if LangeKuerzel(Wk.MschAltMKlasseColl) or
     LangeKuerzel(Wk.MschAltWKlasseColl) or
     LangeKuerzel(Wk.TlnAltMKlasseColl) or
     LangeKuerzel(Wk.TlnAltWKlasseColl) then Result := true
  else Result := false;
end;
//------------------------------------------------------------------------------
begin
  Result := false;
  if (FVPtr<>nil) and (FVPtr=Veranstaltung) then
    if Self=WettkAlleDummy then
      for i:=0 to Veranstaltung.WettkColl.Count-1 do
        if (Veranstaltung.WettkColl[i].AbschnZahl = 1) and
           LangeKuerzelWk(Veranstaltung.WettkColl[i]) then
        begin
          Result := true;
          Exit;
        end else
    else
      Result := (Self.AbschnZahl = 1) and LangeKuerzelWk(Self);
end;

{//==============================================================================
function TWettkObj.AbsStartMode(Abs:TWkAbschnitt): TStartMode;
//==============================================================================
// stOhnePause,stMassenStart,stJagdStart
// StartMode gleich für alle SGrp in Wettk, Wert 1. SGrp gilt
var i : Integer;
begin
  if Abs=wkAbs1 then Result := stMassenStart
                else Result := stOhnePause;
  with TVeranstObj(FVPtr).SGrpColl do
    for i:=0 to Count-1 do
      if (Self=WettkAlleDummy) or (Self=Items[i].Wettkampf) then
      begin
        Result := Items[i].StartModus[Abs];
        Exit;
      end;
end; }

//==============================================================================
function TWettkObj.GetSerAkRngMaxColl(TlnMsch:TTlnMsch;AkWrtg:TKlassenWertung;Sx:TSex): TWordCollection;
//==============================================================================
begin
  Result := nil;
  case TlnMsch of
    tmTln:
      case AkWrtg of
        kwAltKl:  if Sx = cnWeiblich then Result := FRngMaxTlnAkWColl[TVeranstObj(FVPtr).OrtIndex]
                                     else Result := FRngMaxTlnAkMColl[TVeranstObj(FVPtr).OrtIndex];
        kwSondKl: if Sx = cnWeiblich then Result := FRngMaxTlnSkWColl[TVeranstObj(FVPtr).OrtIndex]
                                     else Result := FRngMaxTlnSkMColl[TVeranstObj(FVPtr).OrtIndex];
      end;
    tmMsch:
      case AkWrtg of
        kwAltKl:  if Sx = cnWeiblich then Result := FRngMaxMschAkWColl[TVeranstObj(FVPtr).OrtIndex]
                                     else Result := FRngMaxMschAkMColl[TVeranstObj(FVPtr).OrtIndex];
      end;
  end;
end;


//==============================================================================
procedure TWettkObj.SetSerRngMax(TlnMsch:TTlnMsch;Klasse:TAkObj;Rng:Integer);
//==============================================================================
// wird in TlnErg.BerechneTagesRang (tmTln) und MannschColl.MannschWertung (tmMsch) gesetzt,
// nur für akt. OrtsIndex
begin
  case TlnMsch of
    tmTln:
      case Klasse.Wertung of
        kwAlle:
          FRngMaxTlnAlleColl[TVeranstObj(FVPtr).OrtIndex] := Rng;
        kwSex :
          if Klasse.Sex = cnWeiblich then
            FRngMaxTlnFrauenColl[TVeranstObj(FVPtr).OrtIndex] := Rng
          else
            FRngMaxTlnMaennerColl[TVeranstObj(FVPtr).OrtIndex] := Rng;
        kwAltKl:
          if (Klasse.Sex = cnWeiblich) and (TlnAltWKlasseColl.IndexOf(Klasse) >= 0) then
            FRngMaxTlnAkWColl[TVeranstObj(FVPtr).OrtIndex][TlnAltWKlasseColl.IndexOf(Klasse)] := Rng
          else
          if (Klasse.Sex = cnMaennlich) and (TlnAltMKlasseColl.IndexOf(Klasse) >= 0) then
            FRngMaxTlnAkMColl[TVeranstObj(FVPtr).OrtIndex][TlnAltMKlasseColl.IndexOf(Klasse)] := Rng;
        kwSondKl:
          if (Klasse.Sex = cnWeiblich) and (TlnSondWKlasseColl.IndexOf(Klasse) >= 0) then
            FRngMaxTlnSkWColl[TVeranstObj(FVPtr).OrtIndex][TlnSondWKlasseColl.IndexOf(Klasse)] := Rng
          else
          if (Klasse.Sex = cnMaennlich) and (TlnSondMKlasseColl.IndexOf(Klasse) >= 0) then
            FRngMaxTlnSkMColl[TVeranstObj(FVPtr).OrtIndex][TlnSondMKlasseColl.IndexOf(Klasse)] := Rng;
      end;
    tmMsch:
      case Klasse.Wertung of
        kwAlle:
          FRngMaxMschAlleColl[TVeranstObj(FVPtr).OrtIndex] := Rng;
        kwSex :
          if Klasse.Sex = cnWeiblich then
            FRngMaxMschFrauenColl[TVeranstObj(FVPtr).OrtIndex] := Rng
          else
          if Klasse.Sex = cnMixed then
            FRngMaxMschMixedColl[TVeranstObj(FVPtr).OrtIndex] := Rng
          else
            FRngMaxMschMaennerColl[TVeranstObj(FVPtr).OrtIndex] := Rng;
        kwAltKl:
          if (Klasse.Sex = cnWeiblich) and (MschAltWKlasseColl.IndexOf(Klasse) >= 0) then
            FRngMaxMschAkWColl[TVeranstObj(FVPtr).OrtIndex][MschAltWKlasseColl.IndexOf(Klasse)] := Rng
          else
          if (Klasse.Sex = cnMaennlich) and (MschAltMKlasseColl.IndexOf(Klasse) >= 0) then
            FRngMaxMschAkMColl[TVeranstObj(FVPtr).OrtIndex][MschAltMKlasseColl.IndexOf(Klasse)] := Rng;
      end;
  end;
end;

(*============================================================================*)
function TWettkObj.ObjSize: Integer;
(*============================================================================*)
begin
    // Ortsbezogene Daten
  Result := 2*cnSizeOfString +
            2*cnSizeOfInteger + {2*SizeOf(TGesWertung) +} cnSizeOfBoolean +
            cnSizeOfWord + SizeOf(TMschWertung) +
            TlnAltMKlasseColl.CollSize +
            TlnSondMKlasseColl.CollSize +
            MschAltMKlasseColl.CollSize +
            TlnAltWKlasseColl.CollSize +
            TlnSondWKlasseColl.CollSize +
            MschAltWKlasseColl.CollSize +
            FStandTitelColl.CollSize +
            FSondTitelColl.CollSize +
            FDatumColl.CollSize +
            FWettkArtColl.CollSize +
            FMschWrtgModeColl.CollSize +
            FMannschGrAnmColl.CollSize +
            FMannschGrStrtColl.CollSize +
            4*FMschGrAlleColl.CollSize +
            FSchwimmDistanzColl.CollSize +
            FStartBahnenColl.CollSize +
            FErgModifiedColl.CollSize +
            FAbschnZahlColl.CollSize +
            cnAbsZahlMax*FAbschnNameCollArr[wkAbs1].CollSize +
            FTlnTxtColl.CollSize +
            cnAbsZahlMax*FAbschnRundCollArr[wkAbs1].CollSize +
            TlnImZielColl.CollSize +
            RngBuffColl.CollSize +
            FTlnCupWrtgPktColl.CollSize +
            FMschCupWrtgPktColl.CollSize+
            7*FRngMaxTlnAlleColl.CollSize;
end;


(******************************************************************************)
(* Methoden von TWettkColl                                                    *)
(******************************************************************************)

// protected Methoden

(*----------------------------------------------------------------------------*)
function TWettkColl.GetBPObjType: Word;
(*----------------------------------------------------------------------------*)
(* Object Types aus Version 7.4 Stream Registration Records *)
begin
  Result := rrWettkColl;
end;

(*----------------------------------------------------------------------------*)
function TWettkColl.GetPItem(Indx:Integer): TWettkObj;
(*----------------------------------------------------------------------------*)
// kein Range-Prüfung wegen Geschwindigkeit
begin
  Result := TWettkObj(inherited GetPItem(Indx));
end;

(*----------------------------------------------------------------------------*)
procedure TWettkColl.SetPItem(Indx:Integer; Item:TWettkObj);
(*----------------------------------------------------------------------------*)
begin
  inherited SetPItem(Indx,Item);
end;

(*----------------------------------------------------------------------------*)
function TWettkColl.GetSortItem(Indx:Integer): TWettkObj;
(*----------------------------------------------------------------------------*)
begin
  Result := TWettkObj(inherited GetSortItem(Indx));
end;

// public Methoden

(*============================================================================*)
constructor TWettkColl.Create(Veranst:Pointer; ItemClass:TTriaObjClass);
(*============================================================================*)
begin
  inherited Create(Veranst,ItemClass);
  FStepProgressBar      := true;
  FSortItems.Duplicates := true; (* damit gleiche Einträge aufgelistet werden *)
  FSortMode             := smWkEingegeben;
end;

(*============================================================================*)
function TWettkColl.SortString(Item:Pointer): String;
(*============================================================================*)
begin
  if (Item <> nil) and (IndexOf(Item) >= 0) then
    Result := Format('%2u',[IndexOf(Item)])
  else Result := ' ';
end;

(*============================================================================*)
function TWettkColl.Compare(Item1, Item2: Pointer): Integer;
(*============================================================================*)
begin
  // WettkAlleDummy immer an 1. Stelle
  if Item1 = WettkAlleDummy then Result := -1
  else if Item2 = WettkAlleDummy then Result := 1
  else
  begin
    Result := AnsiCompareStr(SortString(Item1),SortString(Item2));
    // Unterschied ss/ß berücksichtigen
    if Result = 0 then
      Result := CompareStr(SortString(Item1),SortString(Item2));
  end;
end;

(*============================================================================*)
function TWettkColl.Load: Boolean;
(*============================================================================*)
// angepasst an BP-Version
var
  ObjType : Word;
  i,j : Integer;
  B : byte;
  C : Word;
  SI: SmallInt;
  StreamPosAlt : Int64;
  WkAlleBuf : TWettkObj;
  Abs : TWkAbschnitt;

  begin

  Result := false;
  WkAlleBuf := TWettkObj.Create(FVPtr,Self,oaNoAdd);
  try

    if TriaStream = nil then Exit;

    if FStepProgressBar then StreamPosAlt := TriaStream.Position
    else StreamPosAlt := 0;

    try
      // read dummy Byte
      TriaStream.ReadBuffer(B,cnSizeOfByte);
      TriaStream.ReadBuffer(ObjType,cnSizeOfWord);

      if TriDatei.Version.Jahr < '2010' then
        if not WkAlleBuf.Load then Exit; // WettkAlleDummy ab 2010 nicht mehr benutzt

      TriaStream.ReadBuffer(C,cnSizeOfWord);
      if (TriDatei.Version.Jahr<'2008')or
         (TriDatei.Version.Jahr='2008')and(TriDatei.Version.Nr<'2.0') then
       begin
         // Dummy Read FLimit,FDelta
         TriaStream.ReadBuffer(SI,cnSizeOfSmallInt);
         TriaStream.ReadBuffer(SI,cnSizeOfSmallInt);
       end;

      if FStepProgressBar then
      begin
        HauptFenster.ProgressBarStep(TriaStream.Position - StreamPosAlt);
        StreamPosAlt := TriaStream.Position;
      end;

      SetCapacity(C); // zur Leistungssteigerung
      for i:=0 to C-1 do
      begin
        if not LoadItem(i) then Exit;
        if (TriDatei.Version.Jahr < '2010') and
           (TVeranstObj(FVPtr).Art=vaLiga) then //Daten von WkAlleBuf für jeden Wettk übernehmen
          with Items[i] do
          begin
            TlnMKlasse.Name := WkAlleBuf.TlnMKlasse.Name;
            TlnWKlasse.Name := WkAlleBuf.TlnWKlasse.Name;
            KlasseCollKopieren(TlnSondMKlasseColl,WkAlleBuf.TlnSondMKlasseColl);
            KlasseCollKopieren(TlnSondWKlasseColl,WkAlleBuf.TlnSondWKlasseColl);
            KlasseCollKopieren(TlnAltMKlasseColl,WkAlleBuf.TlnAltMKlasseColl);
            KlasseCollKopieren(TlnAltWKlasseColl,WkAlleBuf.TlnAltWKlasseColl);
            // Ortsbezogene Daten
            for j:=0 to TVeranstObj(FVPtr).OrtZahl-1 do
            begin
              OrtSondTitel[j] := WkAlleBuf.OrtSondTitel[j];
              OrtDatum[j]:= WkAlleBuf.OrtDatum[j];
              OrtAbschnZahl[j] := WkAlleBuf.OrtAbschnZahl[j];
              for Abs:=wkAbs1 to TWkAbschnitt(OrtAbschnZahl[j]) do
                OrtAbschnName[j,Abs] := WkAlleBuf.OrtAbschnName[j,Abs];
              for Abs:=wkAbs1 to TWkAbschnitt(OrtAbschnZahl[j]) do
                FAbschnRundCollArr[Abs][j]:= Max(1,WkAlleBuf.FAbschnRundCollArr[Abs][j]);
              OrtWettkArt[j] := WkAlleBuf.OrtWettkArt[j];
              OrtSchwimmDistanz[j] := WkAlleBuf.OrtSchwimmDistanz[j];
              OrtStartBahnen[j] := WkAlleBuf.OrtStartBahnen[j];
              OrtTlnTxt[j] := WkAlleBuf.OrtTlnTxt[j];
            end;
          end;

        if FStepProgressBar then
        begin
          HauptFenster.ProgressBarStep(TriaStream.Position - StreamPosAlt);
          StreamPosAlt := TriaStream.Position;
        end;
      end;
      SetItemSize;
    except
      Exit;
    end;

    Result := true;

  finally
    FreeAndNil(WkAlleBuf);
  end;
end;

(*============================================================================*)
function TWettkColl.Store: Boolean;
(*============================================================================*)
var
  i : Integer;
  B : byte;
  C : Word;
begin
  Result := false;
  try
    if TriaStream = nil then Exit;
    SetItemSize;
    B := 0;  // write dummy Byte
    TriaStream.WriteBuffer(B,cnSizeOfByte);
    C := BPObjType;
    TriaStream.WriteBuffer(C,cnSizeOfWord);
    C := Count;
    TriaStream.WriteBuffer(C,cnSizeOfWord);
    if FStepProgressBar then HauptFenster.ProgressBarStep(cnMinCollSize);
    for i:=0 to C-1 do
    begin
      if not StoreItem(i) then Exit;
      if FStepProgressBar then HauptFenster.ProgressBarStep(FItemSize);
    end;
  except
    Exit;
  end;
  Result := true;
end;

(*============================================================================*)
procedure TWettkColl.OrtCollExch(Idx1,Idx2:Integer);
(*============================================================================*)
begin
  if (Idx1<0) or (Idx1>TVeranstObj(FVPtr).OrtZahl-1) then Exit;
  if (Idx2<0) or (Idx2>TVeranstObj(FVPtr).OrtZahl-1) then Exit;
  inherited OrtCollExch(Idx1,Idx2);
end;

(*============================================================================*)
procedure TWettkColl.Sortieren(SortModeNeu:TSortMode);
(*============================================================================*)
// Reihenfolge fest, wie in WettkColl
var i : Integer;
begin
  FSortMode := SortModeNeu;
  SortClear;
  if FSortItems.Capacity < FItems.Capacity+1 then
    FSortItems.Capacity := FItems.Capacity + 1;
  if (FSortMode = smWkPlusAlle) or (FSortMode = smWkNurAlle) then
    AddSortItem(WettkAlleDummy);
  if FSortMode <> smWkNurAlle then // smWkEingegeben, smWkPlusAlle
    for i:=0 to Count-1 do AddSortItem(GetPItem(i));
end;

(*============================================================================*)
function TWettkColl.MannschWettk: Boolean;
(*============================================================================*)
var i : Integer;
begin
  Result := false;
  for i:=0 to Count-1 do
    if TWettkObj(FItems[i]).MschWettk then
    begin
      Result := true;
      Exit;
    end;
end;

{==============================================================================}
function TWettkColl.AlleAbschnGleich: Boolean;
{==============================================================================}
var i,AbsZahlAlle  : Integer;
    AbsNameAlleArr : array [wkAbs1..wkAbs8] of String;
    AbsRndAlleArr  : array [wkAbs1..wkAbs8] of Integer;
    StrtMode       : TStartMode;
    AbsCnt         : TWkAbschnitt;
begin
  Result := false;
  if (FVPtr<>nil) and (Count > 1) then
  begin
    with Items[0] do
    begin
      StrtMode  := TVeranstObj(FVPtr).SGrpColl.WettkStartModus(Items[0],wkAbs1);
      AbsZahlAlle := GetAbschnZahl;
      for AbsCnt:=wkAbs1 to wkabs8 do
      begin
        AbsNameAlleArr[AbsCnt] := GetAbschnName(AbsCnt);
        AbsRndAlleArr[AbsCnt]  := GetAbschnRunden(AbsCnt);
      end;
    end;
    for i:=1 to Count-1 do with Items[i] do
    begin
      if StrtMode <> TVeranstObj(FVPtr).SGrpColl.WettkStartModus(Items[i],wkAbs1) then Exit;
      if AbsZahlAlle <> GetAbschnZahl then Exit;
      for AbsCnt:=wkAbs1 to wkabs8 do
        if (AbsNameAlleArr[AbsCnt] <> GetAbschnName(AbsCnt)) or
           (AbsRndAlleArr[AbsCnt]  <> GetAbschnRunden(AbsCnt)) then Exit;
    end;
  end;
  Result := true;
end;

{==============================================================================}
function TWettkColl.KeinOderAlleTlnStaffel: Boolean;
{==============================================================================}
// true wenn keine oder alle TlnStaffel
var i,j : Integer;
begin
  Result := false;
  for i:=0 to Count-1 do
    for j:=i+1 to Count-1 do
      if (GetPItem(i).WettkArt = waTlnStaffel) <>
         (GetPItem(j).WettkArt = waTlnStaffel) then Exit;
  Result := true;
end;

{==============================================================================}
function TWettkColl.AlleMitSchwDistanz: Boolean;
{==============================================================================}
var i : Integer;
begin
  Result := false;
  for i:=0 to Count-1 do
    if Items[i].GetSchwimmDistanz = 0 then Exit;
  Result := true;
end;


(*============================================================================*)
(*     Methoden von TReportWkObj                                              *)
(*============================================================================*)

//==============================================================================
constructor TReportWkObj.Create(WkNeu:TWettkObj; WrtgNeu:TWertungMode);
//==============================================================================
begin
  Wettk := WkNeu;
  Wrtg  := WrtgNeu;
end;

//==============================================================================
function TReportWkObj.Name: String;
//==============================================================================
begin
  if Wrtg = wgStandWrtg then Result := Wettk.Name
                        else Result := Wettk.SondTitel;
end;

end.
